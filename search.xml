<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021上海ICPC--H.Life is a Game--Kruskal重构树--铜牌拦路虎</title>
    <url>/2021/11/30/2021%E4%B8%8A%E6%B5%B7ICPC--H.Life%20is%20a%20Game--Kruskal%E9%87%8D%E6%9E%84%E6%A0%91--%E9%93%9C%E7%89%8C%E6%8B%A6%E8%B7%AF%E8%99%8E/</url>
    <content><![CDATA[<p>差不多两个小时的时候过了4题，在铜尾，看了一下榜单，去掉打星还有30名左右可以掉，起初掉的很慢，自以为还是很有希望的，然后看着H题过得越来越多，但是三个没有丝毫思路，在封榜前掉出了奖牌区。最后开了J，交了274发随机，赛后看了下得分，有近10发已经过了80%了，还是被大数据卡掉了。归根结底，与铜牌失之交臂的罪魁祸首就是Kruskal重构树，学了一下还是很简单的，要是赛时翻一翻打印出来的oiwiki的图论说不定能翻到。</p>
<p>上上场ccpc威海因为被卡常了，差了两发罚时，也是铁首。以两个铁首结尾还是感到遗憾，寄希望于明年昆明了，寒假一定好好训练。</p>
<h1 id="Kruskal重构树"><a href="#Kruskal重构树" class="headerlink" title="Kruskal重构树"></a>Kruskal重构树</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Kruskal 重构树是图的一种生成树，主要解决路径边权限制问题。Kruskal 重构树有按深度单调的性质，所以很容易就可以解决边权的取值限制。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>顾名思义，这个算法和求最小生成树的Kruskal非常类似。</p>
<ol>
<li>把所有边按照边权从小到大排序</li>
<li>按顺序遍历每一条边（a,b,c），如果a，b已经在一个联通块内了，则跳过，否则我们构造一个新点x，由它来连接这两个点，然后x的点权就是c。并且将并查集的祖先设为x，即fa[a] = fa[b] = x;</li>
</ol>
<p><img src="https://i.loli.net/2021/11/30/B6jgQR8LEU7Yhet.png" alt="image.png"></p>
<h3 id="重构树的性质"><a href="#重构树的性质" class="headerlink" title="重构树的性质"></a>重构树的性质</h3><p>1.重构树的节点个数是2*n-1，因为树的每条边成为一个新增节点。<br>2.原来的点都是叶子结点<br>3.这是一棵二叉树，最后增加的点是根节点<br>4.新增点的点权按加入顺序是非严格递增的<br>5.从一个点x（通常是原图的点，也就是新图里的叶子结点）出发经过的边边权&lt;=w能到达的点就是从x出发找到第一个祖先节点ed，ed的点权&gt;w，则该点的子树的叶子节点就是原来图中能到达的所有点。</p>
<hr>
<p><a href="https://ac.nowcoder.com/acm/contest/24872/H">Life is a Game</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给你一张图和所有点的点权，所有边的边权。然后有1e5次询问，每次给你一个起点st和一个金币数val，每走到一个点金币数可以加上点权，但是只有金币数大于等于边权才能走那条边，通过一条边不会消耗金币，问最后的金币数是多少。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最后不能走的条件就是当前已走过的点的点权和加上初始的值小于周围可走边的权值，是一个边权限制的问题（有点强行解释），理所应当的我们想到Kruskal重构树（屁嘞，学都没学过）。</p>
<p>我们画出样例的重构树<br><img src="https://pic.baixiongz.com/uploads/2021/11/30/24a4f27006dcc.jpeg" alt="1"></p>
<p>根据题意我们知道停止移动的条件是新点的点权（原来的边权）减去经过的所有点的点权和（也就是他的子树所有点权和） &gt; val。因为边权在递增，子树点权和也在递增，所以停止的点可能有很多个，且不是连续的，我们要找到最靠近起点的，也就是深度最深的。</p>
<ul>
<li>我们可以对新增的点维护一个他子树所有点权和</li>
<li>然后用两个跳表，一个是pre来维护节点编号，一个v（表示边权减去子树所有点权和）来维护最大值，用来快速找到最接近起点的终止位置。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CN puts(<span class="meta-string">&quot;NO&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CY puts(<span class="meta-string">&quot;YES&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a,b,c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.c &lt; b.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fa[x] == x ? x : (fa[x]=<span class="built_in">find</span>(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[maxn][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[maxn][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">2</span>*N) fa[i] = i;<span class="comment">//最后点的个数是2*N-1</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N) cin &gt;&gt; A[i];</span><br><span class="line">	vector&lt;Edge&gt; edge;</span><br><span class="line">	<span class="keyword">while</span>(M--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, w;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		edge.<span class="built_in">pb</span>(&#123;u,v,w&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(edge),cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> node = N + <span class="number">1</span>;<span class="comment">//新增点开始编号</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> e : edge)&#123;</span><br><span class="line">		<span class="keyword">int</span> a = e.a, b = e.b, c = e.c;</span><br><span class="line">		<span class="keyword">int</span> ra = <span class="built_in">find</span>(a), rb = <span class="built_in">find</span>(b);</span><br><span class="line">		<span class="keyword">if</span>(ra != rb)&#123;</span><br><span class="line">			A[node] = A[ra] + A[rb];<span class="comment">//子树的点权和，不包括自己</span></span><br><span class="line">			pre[ra][<span class="number">0</span>] = pre[rb][<span class="number">0</span>] = node;<span class="comment">//上面一个节点的编号 </span></span><br><span class="line">			<span class="comment">//处理跳表</span></span><br><span class="line">			v[ra][<span class="number">0</span>] = c - A[ra];</span><br><span class="line">			v[rb][<span class="number">0</span>] = c - A[rb];</span><br><span class="line">			fa[ra] = fa[rb] = node++;<span class="comment">//合并并查集</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//预处理</span></span><br><span class="line">	<span class="built_in">per</span>(i,node<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,<span class="number">18</span>)&#123;</span><br><span class="line">			pre[i][j] = pre[pre[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">			v[i][j] = <span class="built_in">max</span>(v[i][j<span class="number">-1</span>],v[pre[i][j<span class="number">-1</span>]][j<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,Q)&#123;</span><br><span class="line">		<span class="keyword">int</span> st,val;</span><br><span class="line">		cin &gt;&gt; st &gt;&gt; val;</span><br><span class="line">		<span class="built_in">per</span>(j,<span class="number">18</span>,<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(pre[st][j]!=<span class="number">0</span> &amp;&amp; v[st][j]&lt;=val) st = pre[st][j];<span class="comment">//等于0说明跳到2*N-1之外了（不存在的点）；最大值小于等于val说明st到pre[st][j]路径中间都是满足的，所以继续往根节点跳</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//最后st就是不能走的那个点</span></span><br><span class="line">		cout &lt;&lt; val + A[st] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IOS</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论 | icpc/ccpc</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round 753</title>
    <url>/2021/11/03/Codeforces%20Round%20753/</url>
    <content><![CDATA[<blockquote>
<p>上场div2被卡到了1599，本来这场不掉分就能上蓝，却被D卡了一个小时，E17分钟就1A了。为什么rank1096也会掉分，div3太难上分了。-_-‘’</p>
</blockquote>
<h1 id="A-Linear-Keyboard"><a href="#A-Linear-Keyboard" class="headerlink" title="A. Linear Keyboard"></a>A. Linear Keyboard</h1><p>题意：先给你一个字典，再给你一个字符串，求字符串中相邻两个字母在字典中距离的和。</p>
<p>思路：用map简单映射一下就好了</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Problem: A. Linear Keyboard</span></span><br><span class="line"><span class="comment">// Contest: Codeforces Round #753 (Div. 3)</span></span><br><span class="line"><span class="comment">// URL: https://codeforces.com/contest/1607/problem/A</span></span><br><span class="line"><span class="comment">// Memory Limit: 256 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	cin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line">vi G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line"></span><br><span class="line">		string s1,s;</span><br><span class="line">		cin &gt;&gt; s1 &gt;&gt; s;</span><br><span class="line">		N = <span class="built_in">sz</span>(s);</span><br><span class="line">		map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; pos;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="built_in">sz</span>(s1)<span class="number">-1</span>)&#123;</span><br><span class="line">			pos[s1[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>)&#123;</span><br><span class="line">			ans+=<span class="built_in">abs</span>(pos[s[i]]-pos[s[i<span class="number">-1</span>]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">wtl</span>(ans);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></h2><h1 id="B-Odd-Grasshopper"><a href="#B-Odd-Grasshopper" class="headerlink" title="B. Odd Grasshopper"></a>B. Odd Grasshopper</h1><p>题意：给定一个初始位置x，需要移动的步数n，第i步的步长为i，求最后所在的位置。</p>
<p>思路：手写几项可以发现（起点为偶数）四步后的位置的变化值是-1+2+3-4=0，-5+6+7-8=0…所以每四步都会回到起点，只需把n对4取模再模拟剩下的几步（小于4步）。</p>
<p>赛时逆天写了奇偶的分类讨论，人傻掉了😞</p>
<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Problem: B. Odd Grasshopper</span></span><br><span class="line"><span class="comment">// Contest: Codeforces Round #753 (Div. 3)</span></span><br><span class="line"><span class="comment">// URL: https://codeforces.com/contest/1607/problem/B</span></span><br><span class="line"><span class="comment">// Memory Limit: 256 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	cin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line">vi G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="keyword">int</span> now,ans;</span><br><span class="line">		cin &gt;&gt; now &gt;&gt; N;</span><br><span class="line">		<span class="built_in">rep</span>(i,N/<span class="number">4</span>*<span class="number">4</span>+<span class="number">1</span>,N)&#123;</span><br><span class="line">			<span class="keyword">if</span>(now&amp;<span class="number">1</span>) now+=i;</span><br><span class="line">			<span class="keyword">else</span> now-=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">wtl</span>(now);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="分类讨论"><a href="#分类讨论" class="headerlink" title="分类讨论"></a>分类讨论</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Problem: B. Odd Grasshopper</span></span><br><span class="line"><span class="comment">// Contest: Codeforces Round #753 (Div. 3)</span></span><br><span class="line"><span class="comment">// URL: https://codeforces.com/contest/1607/problem/B</span></span><br><span class="line"><span class="comment">// Memory Limit: 256 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	cin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line">vi G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="keyword">int</span> now,ans;</span><br><span class="line">		cin &gt;&gt; now &gt;&gt; N;</span><br><span class="line">		<span class="keyword">if</span>(now&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> ci = N/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(ci&amp;<span class="number">1</span>)&#123;</span><br><span class="line">				 <span class="keyword">if</span>((N&amp;<span class="number">1</span>)==<span class="number">0</span>) ans = now<span class="number">-1</span>;</span><br><span class="line">				 <span class="keyword">else</span> ans = now<span class="number">-1</span>-N;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>((N&amp;<span class="number">1</span>)==<span class="number">0</span>) ans = now;</span><br><span class="line">				<span class="keyword">else</span> ans = now+N;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> ci = N/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(ci&amp;<span class="number">1</span>)&#123;</span><br><span class="line">				 <span class="keyword">if</span>((N&amp;<span class="number">1</span>)==<span class="number">0</span>) ans = now+<span class="number">1</span>;</span><br><span class="line">				 <span class="keyword">else</span> ans = now+<span class="number">1</span>+N;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>((N&amp;<span class="number">1</span>)==<span class="number">0</span>) ans = now;</span><br><span class="line">				<span class="keyword">else</span> ans = now-N;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">wtl</span>(ans);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></h2><h1 id="C-Minimum-Extraction"><a href="#C-Minimum-Extraction" class="headerlink" title="C. Minimum Extraction"></a>C. Minimum Extraction</h1><p>题意：给你一个数组，每次选择其中最小的一个x，让剩余元素减去x，再把x从数组中删除，知道数组为空。问每次删除前数组中最小值的最大值是多少。</p>
<p>思路：首先发现所有数减去一个相同的数并不会改变他们的相对大小，所以删去的顺序就是按照原数组从小到大。先从小到大排序，那么第i次删除前的最小值就是a[i]-a[i-1] (a[0]是0)，然后$O(n)$遍历取max</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Problem: C. Minimum Extraction</span></span><br><span class="line"><span class="comment">// Contest: Codeforces Round #753 (Div. 3)</span></span><br><span class="line"><span class="comment">// URL: https://codeforces.com/contest/1607/problem/C</span></span><br><span class="line"><span class="comment">// Memory Limit: 256 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	cin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line">vi G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		cin &gt;&gt; N;</span><br><span class="line">		<span class="keyword">int</span> mmax = -INF_L;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">			cin &gt;&gt; A[i];		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(A+<span class="number">1</span>,A+<span class="number">1</span>+N);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">			mmax = <span class="built_in">max</span>(mmax,A[i]-A[i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">wtl</span>(mmax);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></h2><h1 id="D-Blue-Red-Permutation"><a href="#D-Blue-Red-Permutation" class="headerlink" title="D. Blue-Red Permutation"></a>D. Blue-Red Permutation</h1><p>题意：有n个点的坐标，颜色；红色可以往右移，蓝色可以往左移。问能否将所有点移到1-n，每个位置一个点。</p>
<p>思路：首先有一种不满足的情况是<1的位置有蓝色的点或者>n的位置有红色的点那么这些点无法移动到区间[1,n]，一定是NO。<br>若有满足条件得情况如RBRBR那么一定可以变成BBRRR，也就是蓝色都在左边，红色都在右边。<br>所以我们将红蓝位置分别排序，从小到大枚举蓝色，如果坐标小于已经枚举得点就是NO，相当于左边放不下这么多蓝色；红色同理。</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Problem: D. Blue-Red Permutation</span></span><br><span class="line"><span class="comment">// Contest: Codeforces Round #753 (Div. 3)</span></span><br><span class="line"><span class="comment">// URL: https://codeforces.com/contest/1607/problem/D</span></span><br><span class="line"><span class="comment">// Memory Limit: 256 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	cin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line">vi G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		cin &gt;&gt; N;</span><br><span class="line">		string s;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N) cin &gt;&gt; A[i];</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		s = <span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[i]&lt;<span class="number">1</span>&amp;&amp;s[i]==<span class="string">&#x27;B&#x27;</span>) f = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(A[i]&gt;N&amp;&amp;s[i]==<span class="string">&#x27;R&#x27;</span>) f = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(f==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[i]&lt;<span class="number">1</span>||A[i]&gt;N) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">				B.<span class="built_in">pb</span>(A[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				R.<span class="built_in">pb</span>(A[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(<span class="built_in">all</span>(B));</span><br><span class="line">		<span class="built_in">sort</span>(<span class="built_in">all</span>(R));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="built_in">sz</span>(B)<span class="number">-1</span>)&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(B[i]&lt;(i+<span class="number">1</span>)) &#123;</span><br><span class="line">				f = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">per</span>(i,<span class="built_in">sz</span>(R)<span class="number">-1</span>,<span class="number">0</span>)&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>((N-R[i]+<span class="number">1</span>)&lt;(<span class="built_in">sz</span>(R)-i)) &#123;</span><br><span class="line">				f = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></h2><h1 id="E-Robot-on-the-Board-1"><a href="#E-Robot-on-the-Board-1" class="headerlink" title="E. Robot on the Board 1"></a>E. Robot on the Board 1</h1><p>题意：有一串指令s和一个n*m的矩形，问将机器人放在哪个位置，能够执行尽可能多的步数。（走出矩形即结束或指令全执行完）</p>
<p>思路：不管从那个点开始，执行指令的路径事固定的，只要整个路径在矩形内就可以。一个路径能在矩形内，最右边-最左边<m && 最下边-最上边<n。所以我们只要遍历指令直到不符合条件break。然后把此时路径外切矩形的左上点放在（1，1），可以求出路径起点（0，0）在原坐标系的坐标。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Problem: E. Robot on the Board 1</span></span><br><span class="line"><span class="comment">// Contest: Codeforces Round #753 (Div. 3)</span></span><br><span class="line"><span class="comment">// URL: https://codeforces.com/contest/1607/problem/E</span></span><br><span class="line"><span class="comment">// Memory Limit: 256 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 2000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	cin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line">vi G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">		string s;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="built_in">sz</span>(s);</span><br><span class="line">		<span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>,R=<span class="number">0</span>,U=<span class="number">0</span>,D=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>) x--;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>) x++;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;U&#x27;</span>) y--;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>) y++;</span><br><span class="line">			<span class="keyword">int</span> tl = L,tr = R, tu = U, td = D;</span><br><span class="line">			L = <span class="built_in">min</span>(L,x);</span><br><span class="line">			R = <span class="built_in">max</span>(R,x);</span><br><span class="line">			D = <span class="built_in">max</span>(D,y);</span><br><span class="line">			U = <span class="built_in">min</span>(U,y);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(R-L)&gt;=M||<span class="built_in">abs</span>(U-D)&gt;=N)&#123;</span><br><span class="line">				L = tl;</span><br><span class="line">				R = tr;</span><br><span class="line">				U = tu;</span><br><span class="line">				D = td;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		U--;</span><br><span class="line">		L--;</span><br><span class="line">		<span class="built_in">wtb</span>(-U);</span><br><span class="line">		<span class="built_in">wtl</span>(-L);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round 754 (Div. 2)</title>
    <url>/2021/11/13/Codeforces%20Round%20754%20(Div.%202)/</url>
    <content><![CDATA[<blockquote>
<p>赛时只做出了ABC，D想的很接近了，但是后面染色的部分没搞出来<br>Anyway，我上蓝了！！！😄无数次接近1600，然后晋级赛就像被降智了一样掉大分。<br><img src="/upload/2021/11/WechatIMG13-5c1549fe9b4e416590f62978dc9f9db4.png" alt="WechatIMG13.png"></p>
</blockquote>
<hr>
<h3 id="A-A-M-Deviation"><a href="#A-A-M-Deviation" class="headerlink" title="A. A.M. Deviation"></a>A. A.M. Deviation</h3><p><strong>题意：</strong> 给你a，b，c三个数，求$<code>|a+c-2 × c|</code>$ 的最小值。然后你可以</p>
<ul>
<li>把a或c加1，然后b减1</li>
<li>把a或c减1，然后b加1<br>可以操作无限次</li>
</ul>
<p><strong>题解：</strong> 每次操作对答案的影响是3，所以我们只需要对($<code>a+c-2 × c</code>$)%3,那么答案可能是-2，-1，0，1，2；当等于-2时可以加3变成1，当等于2时可以减3等于-1.所以答案只有0或1，且只有原来等于0的是0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M,K;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn],dp[maxn],f[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, c;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">	<span class="keyword">int</span> dif = (a+c<span class="number">-2</span>*b)%<span class="number">3</span>;</span><br><span class="line">	<span class="built_in">wtl</span>(dif?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="B-Reverse-Sort"><a href="#B-Reverse-Sort" class="headerlink" title="B. Reverse Sort"></a>B. Reverse Sort</h3><p><strong>题意：</strong> 给你一个01串，将它变成非降序。</p>
<ul>
<li>每次操作选择一个非增序的非连续子串，使其变成非降序。<br>问最少需要几次操作</li>
</ul>
<p><strong>题解：</strong> 首先我们可以肯定的是最后的字符串一定是前面连续0，后面连续1（0000001111）。那么我们只需要把后面应该是1的0和前面应该是0的1排序即可。且这样选择的子串保证是非增序的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M,K;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn],dp[maxn],f[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line"><span class="keyword">int</span> sum1;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	sum1 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,N<span class="number">-1</span>)&#123;</span><br><span class="line">		sum1+=(s[i]==<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ordered = <span class="number">1</span>,cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,N-sum1<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">			ordered = <span class="number">0</span>;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ordered)&#123;</span><br><span class="line">		<span class="built_in">wtl</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">wtl</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">wtb</span>(cnt*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,N-sum1<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>) <span class="built_in">wtb</span>(i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,N-sum1,N<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>) <span class="built_in">wtb</span>(i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="C-Dominant-Character"><a href="#C-Dominant-Character" class="headerlink" title="C. Dominant Character"></a>C. Dominant Character</h3><p><strong>题意：</strong> 给你一个只包含‘a’，‘b’，‘c’的字符串，找到长度&gt;1的最短的连续子串满足，a的个数严格大于b，c的个数。找不到输出-1.</p>
<p><strong>题解：</strong> 答案其实只有-1，2，3，4，7这五种，枚举长度再暴力check就好了。</p>
<ul>
<li>如果存在aa，那么答案就是2</li>
<li>当a…a中间有x个b，y个c时，当y和x大于1时就不成立了，所以只能是aba或aca，答案是3；或者abca，acba，答案是4</li>
<li>或者是a…a…a，此时中间最多放2个b，2个c，只能是abbacca或accabba，答案为7。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M,K;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn],dp[maxn],f[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	<span class="built_in">rep</span>(len,<span class="number">2</span>,<span class="number">7</span>)&#123;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,N<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i+len&gt;N) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">rep</span>(j,i,i+len<span class="number">-1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[j]==<span class="string">&#x27;a&#x27;</span>) a++;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(s[j]==<span class="string">&#x27;b&#x27;</span>) b++;</span><br><span class="line">				<span class="keyword">else</span> c++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(a&gt;b&amp;&amp;a&gt;c)&#123;</span><br><span class="line">				<span class="built_in">wtl</span>(len);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">wtl</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="D-Treelabeling"><a href="#D-Treelabeling" class="headerlink" title="D. Treelabeling"></a>D. Treelabeling</h3><p><strong>题意：</strong> 给你一棵树，每个点都有一个权值，如果两个点权值为u，v，且u^v&lt;=min(u,v)那么这两个点相连。然后两个人依次选择一个点，这个点没被 选过且和前一人选的相连的，选不了的人就输了；第一个人可以从任意一个点开始。请构造一个1-N的排列对应1-N编号点的权值，使得先手必胜的点最多。</p>
<p><strong>题解：</strong> 首先一个结论是先手胜的点最多是N就是每个点都是先手必胜。</p>
<ol>
<li>题目转化成一棵树任意两个相邻点不互通，即（u^v）&gt; min(u,v)，只需要u，v的二进制位数不一样就行。以为异或后的位数和max(u,v)相同，肯定大于min(u,v).</li>
<li>由此我们可以想到染色问题。先将这棵树进行01染色。把节点编号放到所染颜色的集合中。</li>
<li>对于2进制位数相同的权值不能放在相邻两个节点，也就是必须放在同一种颜色的节点。</li>
<li>哪种颜色剩余的多就把当前枚举到的权值放那种颜色的节点里。</li>
<li>枚举权值要从权值位数从大到小枚举，因为如果从小到大，最后一种位数的权值个数很多，大于剩余黑白节点中较多的个数，那么他就会被分到黑色和白色的节点，两者可能是相邻的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M,K;</span><br><span class="line"><span class="keyword">int</span> h_bit[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line">vi G[maxn], node[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;\\预处理每个数的二进制位数</span><br><span class="line">	<span class="keyword">int</span> bit = <span class="number">1</span>, cnt = <span class="number">1</span>, nxt = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">2e5</span>+<span class="number">7</span>)&#123;</span><br><span class="line">		h_bit[i] = bit;</span><br><span class="line">		cnt--;</span><br><span class="line">		<span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">			cnt = nxt;</span><br><span class="line">			bit++;</span><br><span class="line">			nxt&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> col)</span></span>&#123;\\<span class="number">01</span>染色</span><br><span class="line">	node[col].<span class="built_in">pb</span>(u);\\把节点编号存入所染颜色的桶里</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : G[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(x == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(x,u,col^<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N) G[i].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,N)&#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">		G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>);\\染色</span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;vi&gt; <span class="title">v</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">		v[h_bit[i]].<span class="built_in">pb</span>(i);\\把所有权值分类</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">per</span>(i,<span class="number">19</span>,<span class="number">0</span>)&#123;\\枚举二进制长度</span><br><span class="line">		<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">sz</span>(node[<span class="number">1</span>]) &gt; <span class="built_in">sz</span>(node[<span class="number">0</span>])) cur = <span class="number">1</span>;\\选择剩余节点较多的颜色</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : v[i])&#123;\\把当前权值赋值给这个颜色</span><br><span class="line">			<span class="keyword">int</span> t = node[cur].<span class="built_in">back</span>();</span><br><span class="line">			node[cur].<span class="built_in">pop_back</span>();</span><br><span class="line">			ans[t] = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N) <span class="built_in">wtb</span>(ans[i]);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round 769 (Div. 2) E2. Distance Tree (hard version)</title>
    <url>/2022/02/03/Codeforces%20Round%20769%20(Div.%202)%20E2.%20Distance%20Tree%20(hard%20version)/</url>
    <content><![CDATA[<p><strong>题意：</strong><br>-<br>给你一棵树，每条边的权值为1，你可以随便连一条权值为x的边，求任何一点到1号点距离的最大值的最小值。对于x=[1,N]的每一个数输出一个值。</p>
<hr>
<p><strong>思路：</strong><br>-</p>
<ul>
<li>用d[i]表示深度大于i的两个点的对大距离，这可以用dfs来实现，就是每个节点子树中的前二大的深度，计作x，y，那么可以更新d[min(x,y)-1],当我们取一遍后缀max后相当于i小于min(x,y)的d[i]都被更新了，符合我们对d数组的定义。</li>
<li>原来树中的最大深度就是答案的最大值，不会比它更大，因为可以完全不走新加的那条边。</li>
<li>新加的边一定是根结点和某个点连。</li>
<li>当x增加的时候，ans必然不会减少。因为我们把路径分为两类，第一类是经过新加边的，第二类是只经过原来的边的。随着x的增加一个节点到1号点的距离会不断从第一类到第二类。而第一类是随着x增加的，第二类是固定的他比之前的第一类大，比后来的第一类小。这样就可以双指针x和ans了。</li>
</ul>
<p><strong>代码</strong><br>-<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot; = &quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug2(a,b) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot; = &quot;</span>&lt;&lt;a&lt;&lt;<span class="meta-string">&quot;-----&quot;</span>&lt;&lt;#b&lt;&lt;<span class="meta-string">&quot; = &quot;</span>&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"><span class="keyword">int</span> a[maxn],f[maxn],b[maxn],d[maxn],u[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[<span class="number">4000</span>];</span><br><span class="line">PII v[maxn];</span><br><span class="line"><span class="keyword">int</span> mmax;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = a[u], y = a[u];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j : G[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">		a[j] = a[u] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="built_in">dfs</span>(j,u,a);</span><br><span class="line">		<span class="keyword">if</span> (t &gt; x) &#123;</span><br><span class="line">			y = x;</span><br><span class="line">			x = t;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; y) &#123;</span><br><span class="line">			y = t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="built_in">min</span>(x,y) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		d[i] = <span class="built_in">max</span>(d[i], x + y - <span class="number">2</span> * a[u] + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">	<span class="comment">// return 0;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		G[i].<span class="built_in">clear</span>();</span><br><span class="line">		d[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		G[a].<span class="built_in">pb</span>(b);</span><br><span class="line">		G[b].<span class="built_in">pb</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> x = <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>,a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">		d[i] = <span class="built_in">max</span>(d[i],d[i+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		<span class="comment">//ans&lt;x因为答案不能超过原来树的最大深度</span></span><br><span class="line">		<span class="comment">//深度小于等于ans的节点可以不用经过新加的边</span></span><br><span class="line">		<span class="comment">//深度大于ans的点只要那两个深度前二大的满足其他点也满足。</span></span><br><span class="line">		<span class="comment">//我们只需要连到那两个点的中点看是否满足（d[ans]/2+i &lt;= ans）</span></span><br><span class="line">		<span class="keyword">while</span>(ans &lt; x &amp;&amp; d[ans]/<span class="number">2</span>+i &gt; ans) ans ++;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">  	<span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>codeforces | 树</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round 770 (Div. 2).  F. Fibonacci Additions</title>
    <url>/2022/02/22/Codeforces%20Round%20770%20(Div.%202).%20%20F.%20Fibonacci%20Additions/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你两个数组，每次进行操作后判断两个数组在模mod意义下是否相等。</p>
<ul>
<li>操作A：给a数组l到r区间加上斐波那契数列的前r-l+1项</li>
<li>操作B：给b数组l到r区间加上斐波那契数列的前r-l+1项</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>很自然的，我们想到另c[i] = a[i] - b[i]，这样就把问题转化为了c[i]是否全部是0。</li>
<li><p>接下来就是官方题解很妙的想法（太菜了，没见过）。根据斐波那契数列的规律构建一个D数组，D[1] = c[1], D[2] = c[2] - c[1],一般的D[i] = c[i] - c[i-1] - c[i-2],当D[i]全为0时显然D[i]全为。这样就把问题转化为了D[i]是否全部是0。<br>3.</p>
<ul>
<li>对于操作A，对A加上了一个斐波那契数列，等价于给c加上了斐波那契数列，而对于D的影响则是D[l] += 1, D[r+1] -= F[r-l+2], D[r+2] -= F[r-l+1]</li>
<li>对于操作B，对B加上了一个斐波那契数列，等价于给c减少了斐波那契数列，而对于D的影响则是D[l] -= 1, D[r+1] += F[r-l+2], D[r+2] += F[r-l+1]<br>这样每次操作就变成O(3)修改</li>
</ul>
</li>
<li><p>对于每次操作我们维护一下D数组中0的个数就好。</p>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">fib</span><span class="params">(maxn)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; N &gt;&gt; Q &gt;&gt; mod;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; N; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		a[i] -= x;</span><br><span class="line">		a[i] = (a[i] + mod) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fib.<span class="built_in">resize</span>(N);</span><br><span class="line">	fib[<span class="number">0</span>] = fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++) fib[i] = (fib[i<span class="number">-1</span>] + fib[i - <span class="number">2</span>]) % mod;</span><br><span class="line">		</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">D</span><span class="params">(N)</span></span>;</span><br><span class="line">	D[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span> (N &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">		D[<span class="number">1</span>] = a[<span class="number">1</span>] - a[<span class="number">0</span>]; </span><br><span class="line">		D[<span class="number">1</span>] = ((D[<span class="number">1</span>] % mod) + mod) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		D[i] = (((a[i] - a[i<span class="number">-1</span>] - a[i<span class="number">-2</span>]) % mod) + mod) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> cnt_z = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) cnt_z += D[i] == <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// cout &lt;&lt; cnt_z &lt;&lt; &quot;hhh&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">auto</span> add = [&amp;](<span class="keyword">int</span> p, <span class="keyword">int</span> v) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt;= N) <span class="keyword">return</span>;</span><br><span class="line">		cnt_z -= D[p] == <span class="number">0</span>;</span><br><span class="line">		D[p] = (((D[p] + v) % mod) + mod) % mod;</span><br><span class="line">		cnt_z += D[p] == <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		<span class="keyword">char</span> op;</span><br><span class="line">		<span class="keyword">int</span> l, r;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		l --, r --;</span><br><span class="line">		<span class="keyword">if</span> (op == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">			<span class="built_in">add</span>(l, <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">add</span>(r + <span class="number">1</span>, -fib[r-l+<span class="number">1</span>]);</span><br><span class="line">			<span class="built_in">add</span>(r + <span class="number">2</span>, -fib[r-l]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">add</span>(l, <span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">add</span>(r + <span class="number">1</span>, fib[r-l+<span class="number">1</span>]);</span><br><span class="line">			<span class="built_in">add</span>(r + <span class="number">2</span>, fib[r-l]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt_z == N) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round 775   E.Tyler and Strings</title>
    <url>/2022/03/08/Codeforces%20Round%20775%20%20%20E.Tyler%20and%20Strings%20/</url>
    <content><![CDATA[<h1 id="Tyler-and-Strings"><a href="#Tyler-and-Strings" class="headerlink" title="Tyler and Strings "></a><a href="https://codeforces.com/contest/1649/problem/E">Tyler and Strings </a></h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个a数组和一个b数组，求a数组有几种字典序比b数组小的排列（去重）</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>类似数位dp的思路，如果a数组当前位置放置的数比b数组小，则后面可以随便放。</li>
<li>然后在当前位置放和b数组相同的数继续到下一位。如果这个数放完了，说明这个位置只能放比b数组大的数（放小于的贡献算过了），则break。</li>
<li>当前位置放小于的数的贡献计算<ul>
<li>还剩几个小于b[i]的数pre，这个可以用树状数组维护。</li>
<li>cnt[i]是数字i剩下的个数，则后面随便放去重后的排列有pre <em> fact[后面剩下的位数] / (fact[cnt[1]] </em> fact[cnt[2]] <em> … </em> fact[cnt[k]]).</li>
</ul>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">norm</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x += P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= P) &#123;</span><br><span class="line">        x -= P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">power</span><span class="params">(T a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    T res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Z</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">Z</span>(<span class="keyword">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    Z <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="built_in">norm</span>(P - x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">inv</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, P - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">i64</span>(x) * rhs.x % P;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>/=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>*(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>+(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>-(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>/(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fenwick</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="keyword">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">a</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= n; i += i &amp; -i) &#123;</span><br><span class="line">            a[i - <span class="number">1</span>] += v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//小于x的前缀和</span></span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= i &amp; -i) &#123;</span><br><span class="line">            ans += a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="function">Fenwick&lt;Z&gt; <span class="title">fen</span><span class="params">(<span class="number">2e5</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N)</span>,<span class="title">b</span><span class="params">(M)</span>,<span class="title">cnt</span><span class="params">(maxn)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		a[i] --;</span><br><span class="line">		cnt[a[i]] ++;</span><br><span class="line">		fen.<span class="built_in">add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; b[i];</span><br><span class="line">		b[i] --;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;Z&gt; <span class="title">fact</span><span class="params">(N+<span class="number">7</span>)</span>, <span class="title">infact</span><span class="params">(N+<span class="number">7</span>)</span>, <span class="title">inv</span><span class="params">(N + <span class="number">7</span>)</span></span>;</span><br><span class="line">    fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        fact[i] = fact[i - <span class="number">1</span>] * i;</span><br><span class="line">    &#125;</span><br><span class="line">    infact[N] = fact[N].<span class="built_in">inv</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; i--) &#123;</span><br><span class="line">        infact[i - <span class="number">1</span>] = infact[i] * i;</span><br><span class="line">        inv[i] = infact[i] * fact[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	Z cur = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2e5</span>; i ++) &#123;</span><br><span class="line">		cur *= infact[cnt[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	Z ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(M, N); i ++) &#123;</span><br><span class="line">		ans += cur * fen.<span class="built_in">sum</span>(b[i]) * fact[N - i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (cnt[b[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cur *= cnt[b[i]];</span><br><span class="line">		cnt[b[i]] --;</span><br><span class="line">		fen.<span class="built_in">add</span>(b[i], <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (N &lt; M &amp;&amp; cnt == vector&lt;<span class="keyword">int</span>&gt; (maxn,<span class="number">0</span>)) &#123;</span><br><span class="line">		ans += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; ans.<span class="built_in">val</span>() &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round 776 (Div. 3)  EFG</title>
    <url>/2022/03/09/Codeforces%20Round%20776%20(Div.%203)%20%20EFG/</url>
    <content><![CDATA[<h1 id="E-Rescheduling-the-Exam"><a href="#E-Rescheduling-the-Exam" class="headerlink" title="E. Rescheduling the Exam"></a>E. Rescheduling the Exam</h1><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你N个点的坐标，你可以重置一个点的位置，让每个点和前一个点的距离的最小值最大。（第一个点于前一点的距离是和原点的距离）</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>要想最小距离更大，那我们要移动的点一定是最短距离的两个端点的其中一个。<br>那么这个点有两种去向</p>
<ol>
<li>放在最后，新增一个d - a.back()的线段</li>
<li>放在最大区间的中间，新增一个(max - 1) / 2 的线段<br>对两个点进行相同操作取max</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N + <span class="number">1</span>)</span>,b</span>;</span><br><span class="line">	<span class="comment">// a.push_back(0);</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cin &gt;&gt; a[i];</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">int</span> p, mmin = INF;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] - a[i - <span class="number">1</span>] - <span class="number">1</span> &lt; mmin) &#123;</span><br><span class="line">			mmin = a[i] - a[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">			p = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> las = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i != p) &#123;</span><br><span class="line">			b.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">			las = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; b.<span class="built_in">size</span>(); i ++) v.<span class="built_in">push_back</span>(b[i] - b[i<span class="number">-1</span>] - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="built_in">min</span>(v[<span class="number">0</span>], <span class="built_in">max</span>(M - a[las] - <span class="number">1</span>,(v.<span class="built_in">back</span>() - <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">	v.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">if</span> (p &gt; <span class="number">1</span>) b[p - <span class="number">1</span>] = a[p];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; b.<span class="built_in">size</span>(); i ++) v.<span class="built_in">push_back</span>(b[i] - b[i<span class="number">-1</span>] - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">if</span> (las == p - <span class="number">1</span>) &#123;</span><br><span class="line">		las = p;</span><br><span class="line">	&#125;</span><br><span class="line">	ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(v[<span class="number">0</span>], <span class="built_in">max</span>(M - a[las] - <span class="number">1</span>,(v.<span class="built_in">back</span>() - <span class="number">1</span>) / <span class="number">2</span>)));</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="Vitaly-and-Advanced-Useless-Algorithms"><a href="#Vitaly-and-Advanced-Useless-Algorithms" class="headerlink" title="Vitaly and Advanced Useless Algorithms"></a>Vitaly and Advanced Useless Algorithms</h1><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>你有N个任务，第i个任务要在a[i]之前完成，然后有M种选择，每种选择你可以花费t时间完成第e个任务的百分之p。如果不能完成所有任务输出-1，否则输出选择的数量，和每种选择的数量。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>把所有选择按照是针对哪个任务的分类，对每一个任务的选择集合做一次01背包，背包容量要开到两百，那么完成这个任务的最小花费是dp[100…200]。</p>
<p>然后从前往后枚举每个任务，每次加上完成当前任务的最小花费，如果大于截止时间则输出-1。</p>
<p>由于最后要输出方案，定义dp数组第一位是花费的时间，第二位是已选选择的编号（vector）</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); cout &lt;&lt; endl;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> first,second,id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	vector&lt;node&gt; w[N];</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tt</span><span class="params">(N)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; tt[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> e, t, p;</span><br><span class="line">		cin &gt;&gt; e &gt;&gt; t &gt;&gt; p;</span><br><span class="line">		e --;</span><br><span class="line">		w[e].<span class="built_in">push_back</span>(&#123;t,p,i + <span class="number">1</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	vector&lt;pair&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">cost</span>(N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		vector&lt;pair&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt; &gt; &gt; <span class="built_in">dp</span>(<span class="number">201</span>,&#123;INF,vector&lt;<span class="keyword">int</span>&gt; (<span class="number">0</span>)&#125;);</span><br><span class="line">		dp[<span class="number">0</span>] = &#123;<span class="number">0</span>,vector&lt;<span class="keyword">int</span>&gt; (<span class="number">0</span>)&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; w[i].<span class="built_in">size</span>(); k ++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">100</span> + w[i][k].second; j &gt;= w[i][k].second; j --) &#123;</span><br><span class="line">				<span class="keyword">if</span> (dp[j - w[i][k].second].first + w[i][k].first &lt; dp[j].first) &#123;</span><br><span class="line">					dp[j] = dp[j - w[i][k].second];</span><br><span class="line">					dp[j].first += w[i][k].first;</span><br><span class="line">					dp[j].second.<span class="built_in">push_back</span>(w[i][k].id);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		cost[i] = &#123;INF,vector&lt;<span class="keyword">int</span>&gt; (<span class="number">0</span>)&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">100</span>; j &lt;= <span class="number">200</span>; j ++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cost[i].first &gt; dp[j].first) &#123;</span><br><span class="line">				cost[i] = dp[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		now += cost[i].first;</span><br><span class="line">		ans.<span class="built_in">push_back</span>(cost[i].second);</span><br><span class="line">		res += cost[i].second.<span class="built_in">size</span>();</span><br><span class="line">		<span class="comment">// debug(cost[i].first, i);</span></span><br><span class="line">		<span class="keyword">if</span> (now &gt; tt[i]) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : ans) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> y : x) &#123;</span><br><span class="line">			cout &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="G-Counting-Shortcuts"><a href="#G-Counting-Shortcuts" class="headerlink" title="G. Counting Shortcuts"></a>G. Counting Shortcuts</h1><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>模板题，次短路计数  <a href="https://www.acwing.com/problem/content/385/">原题</a></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>将数组增加一维，代表最短路和次短路，最后判断次短路是否等于最短路+1，是的话就加上次短路的路径数。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> v, c; &#125;;</span><br><span class="line">vector&lt;edge&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> S, F;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dij</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, c, flog;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Dij&amp; r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c&gt;r.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[maxn][<span class="number">2</span>], vis[maxn][<span class="number">2</span>], dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[S][<span class="number">0</span>]=<span class="number">1</span>; dist[S][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;Dij&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>((Dij)&#123;S, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Dij tp = que.<span class="built_in">top</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> u = tp.u, flog = tp.flog;    <span class="comment">//使用这个状态更新其他的</span></span><br><span class="line">        <span class="keyword">if</span>(vis[u][flog]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u][flog] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].v, c = G[u][i].c;</span><br><span class="line">            <span class="keyword">int</span> w = dist[u][flog] + c;</span><br><span class="line">            <span class="keyword">if</span>(w &lt; dist[v][<span class="number">0</span>])    <span class="comment">//更新次短路 最短路</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[v][<span class="number">0</span>] != inf)</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[v][<span class="number">1</span>] = dist[v][<span class="number">0</span>];</span><br><span class="line">                    dp[v][<span class="number">1</span>] = dp[v][<span class="number">0</span>];</span><br><span class="line">                    que.<span class="built_in">push</span>((Dij)&#123;v, dist[v][<span class="number">1</span>], <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                dist[v][<span class="number">0</span>] = w;</span><br><span class="line">                dp[v][<span class="number">0</span>] = dp[u][flog];</span><br><span class="line">                que.<span class="built_in">push</span>((Dij)&#123;v, dist[v][<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w == dist[v][<span class="number">0</span>])      <span class="comment">//更新方法数</span></span><br><span class="line">                (dp[v][<span class="number">0</span>] += dp[u][flog])%=mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w &lt; dist[v][<span class="number">1</span>])   <span class="comment">//更新次短路</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[v][<span class="number">1</span>] = w;</span><br><span class="line">                dp[v][<span class="number">1</span>] = dp[u][flog];</span><br><span class="line">                que.<span class="built_in">push</span>((Dij)&#123;v, dist[v][<span class="number">1</span>], <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w == dist[v][<span class="number">1</span>])    <span class="comment">//更新方法数</span></span><br><span class="line">                (dp[v][<span class="number">1</span>] += dp[u][flog]) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;M);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=N; i++) G[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;S, &amp;F);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            G[u].<span class="built_in">push_back</span>((edge)&#123;v, <span class="number">1</span>&#125;);</span><br><span class="line">            G[v].<span class="built_in">push_back</span>((edge)&#123;u, <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dijkstra</span>();</span><br><span class="line">        <span class="keyword">if</span>(dist[F][<span class="number">1</span>]-dist[F][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (dp[F][<span class="number">0</span>]+dp[F][<span class="number">1</span>])%mod);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[F][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
  </entry>
  <entry>
    <title>Educational Codeforces Round 118</title>
    <url>/2021/12/03/Educational%20Codeforces%20Round%20118%20/</url>
    <content><![CDATA[<h2 id="A-Long-Comparison"><a href="#A-Long-Comparison" class="headerlink" title="A. Long Comparison"></a>A. Long Comparison</h2><p><strong>题意：</strong><br>给你x1，p1，x2，p2，代表了两个数，x1 <em> pow（10，p1）和x2 </em> pow（10，p2），比较两个数的大小。</p>
<p><strong>思路</strong></p>
<ul>
<li>首先比较两个数字的长度，长度长的肯定大（说了没有前导零）</li>
<li>长度相等的情况下，只要把长度短的数字末尾补0补到和长度长的数字一样，然后比较字符串就好了。</li>
</ul>
<p><strong>代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CN puts(<span class="meta-string">&quot;NO&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CY puts(<span class="meta-string">&quot;YES&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> fact[maxn], infact[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jie_init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) fact[i] = fact[i<span class="number">-1</span>] * i % mod;	</span><br><span class="line">	infact[n] = <span class="built_in">qmi</span>(fact[n],mod<span class="number">-2</span>,mod);</span><br><span class="line">	<span class="built_in">per</span>(i,n<span class="number">-1</span>,<span class="number">0</span>) infact[i] = infact[i+<span class="number">1</span>] * (i+<span class="number">1</span>) % mod;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;<span class="keyword">return</span> fact[n] * infact[m] % mod * infact[n-m] % mod;&#125;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn],dp[maxn],f[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a, b, p1, p2;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; p1 &gt;&gt; b &gt;&gt; p2;</span><br><span class="line">	string s1 = <span class="built_in">to_string</span>(a), s2 = <span class="built_in">to_string</span>(b);</span><br><span class="line">	N = s1.<span class="built_in">size</span>(), M = s2.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span>(N+p1&gt;M+p2)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;&gt;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(N+p1&lt;M+p2)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;&lt;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(N&lt;M)&#123;</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">1</span>,M-N) s1 = s1 + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">1</span>,N-M) s2 = s2 + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="built_in">max</span>(<span class="built_in">sz</span>(s1),<span class="built_in">sz</span>(s2))<span class="number">-1</span>)<span class="comment">//其实不用循环，可以直接字符串比较</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s1[i]&gt;s2[i])&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s1[i] &lt; s2[i])&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;&lt;\n&quot;</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;=\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IOS</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="B-Absent-Remainder"><a href="#B-Absent-Remainder" class="headerlink" title="B. Absent Remainder"></a>B. Absent Remainder</h2><p><strong>题意</strong><br>给你n个数，请你找到n/2对数，大数模小数的结果在原来n个数中没有出现过。</p>
<p><strong>思路</strong><br>对于小的数我们总是选择原数列最小的，这样%完的结果一定比最小的数小，那么在原数列这个数肯定不存来。</p>
<p><strong>代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CN puts(<span class="meta-string">&quot;NO&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CY puts(<span class="meta-string">&quot;YES&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> fact[maxn], infact[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jie_init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) fact[i] = fact[i<span class="number">-1</span>] * i % mod;	</span><br><span class="line">	infact[n] = <span class="built_in">qmi</span>(fact[n],mod<span class="number">-2</span>,mod);</span><br><span class="line">	<span class="built_in">per</span>(i,n<span class="number">-1</span>,<span class="number">0</span>) infact[i] = infact[i+<span class="number">1</span>] * (i+<span class="number">1</span>) % mod;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;<span class="keyword">return</span> fact[n] * infact[m] % mod * infact[n-m] % mod;&#125;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn],dp[maxn],f[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N) cin &gt;&gt; A[i];</span><br><span class="line">	<span class="built_in">sort</span>(A+<span class="number">1</span>,A+<span class="number">1</span>+N);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,(N/<span class="number">2</span>)+<span class="number">1</span>)&#123;</span><br><span class="line">		cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; A[<span class="number">1</span>] &lt;&lt; endl;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IOS</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="C-Poisoned-Dagger"><a href="#C-Poisoned-Dagger" class="headerlink" title="C. Poisoned Dagger"></a>C. Poisoned Dagger</h2><p><strong>题意</strong><br>给你一个N，H，代表你攻击的次数，怪物的血量，再给你N个数代表N次攻击的时间点。攻击力为x，指第t秒攻击后，t，t+1…t+x-1，每秒造成一点伤害，如果上一次攻击效果失效之前又进行了一次攻击，那么之前的效果消失，只计算当前最新的攻击。求可以杀死怪物的最小x。</p>
<p><strong>思路</strong><br>如果x攻击力能杀死怪物，那么x+1攻击力一定可以杀死怪物，满足二分性。</p>
<p><strong>代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CN puts(<span class="meta-string">&quot;NO&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CY puts(<span class="meta-string">&quot;YES&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> fact[maxn], infact[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jie_init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) fact[i] = fact[i<span class="number">-1</span>] * i % mod;	</span><br><span class="line">	infact[n] = <span class="built_in">qmi</span>(fact[n],mod<span class="number">-2</span>,mod);</span><br><span class="line">	<span class="built_in">per</span>(i,n<span class="number">-1</span>,<span class="number">0</span>) infact[i] = infact[i+<span class="number">1</span>] * (i+<span class="number">1</span>) % mod;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;<span class="keyword">return</span> fact[n] * infact[m] % mod * infact[n-m] % mod;&#125;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn],dp[maxn],f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ck</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i]+x&gt;=A[i+<span class="number">1</span>])&#123;</span><br><span class="line">			ans+=A[i+<span class="number">1</span>]-A[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ans+=x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans+=x;</span><br><span class="line">	<span class="keyword">if</span>(ans&gt;=M) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N) cin &gt;&gt; A[i];</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = M;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">ck</span>(mid)) r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; l &lt;&lt;endl;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IOS</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="D-MEX-Sequences"><a href="#D-MEX-Sequences" class="headerlink" title="D. MEX Sequences"></a>D. MEX Sequences</h2><p><strong>题意</strong><br>给你一个长度为n的数组，问有多少个子序列（不连续）满足对于子序列中每个元素的值和它的前缀MEX相差绝对值小于等于1.</p>
<p><strong>思路</strong><br>DP</p>
<ol>
<li><p>状态表示 dp[i][0] 表示MEX = i，最大值为i-1 ； dp[i][1] 表示MEX = i，最大值为i+1。<br> 可能会有最大值为i+2的情况，但这种不满足题目要求。</p>
</li>
<li><p>答案累加<br> 当前的数是A[i]，那么加上A[i]后序列符合条件的MEX应该是A[i] ( 不可能，当前的数就是A[i] ), A[i]-1 , A[i]+1。</p>
<ul>
<li>原来的dp[A[i]-1][0] 和 dp[A[i]-1][1]加上一个A[i]后MEX变为A[i]</li>
<li>原来的dp[A[i]][0] 加上一个A[i]后MEX变为A[i]+1</li>
<li><p>原来的dp[A[i]+1][0] 和  dp[A[i]+1][1] 加上一个A[i]后MEX变成A[i]+1</p>
<p><strong>所以答案累加上上述的dp数组就好了</strong></p>
</li>
</ul>
</li>
<li>dp数组更新<br> 当前的数是A[i]<ul>
<li>dp[A[i]-1][1] *= 2    </li>
<li>dp[A[i]-1][1] += dp[A[i]-1][0]</li>
<li>dp[A[i]+1][0] *= 2</li>
<li>dp[A[i]+1][0] += dp[A[i]][0]</li>
<li>dp[A[i]+1][1] *= 2</li>
</ul>
</li>
</ol>
<p><strong>代码</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CN puts(<span class="meta-string">&quot;NO&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CY puts(<span class="meta-string">&quot;YES&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> fact[maxn], infact[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jie_init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) fact[i] = fact[i<span class="number">-1</span>] * i % mod;	</span><br><span class="line">	infact[n] = <span class="built_in">qmi</span>(fact[n],mod<span class="number">-2</span>,mod);</span><br><span class="line">	<span class="built_in">per</span>(i,n<span class="number">-1</span>,<span class="number">0</span>) infact[i] = infact[i+<span class="number">1</span>] * (i+<span class="number">1</span>) % mod;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;<span class="keyword">return</span> fact[n] * infact[m] % mod * infact[n-m] % mod;&#125;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn],dp[maxn][<span class="number">2</span>],f[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N) cin &gt;&gt; A[i];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N+<span class="number">6</span>) dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i]) ans+=dp[A[i]<span class="number">-1</span>][<span class="number">0</span>] + dp[A[i]<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">		ans += dp[A[i]][<span class="number">0</span>] + dp[A[i]+<span class="number">1</span>][<span class="number">0</span>] + dp[A[i]+<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">		ans %= mod;</span><br><span class="line">		<span class="keyword">if</span>(A[i])&#123;</span><br><span class="line">			dp[A[i]<span class="number">-1</span>][<span class="number">1</span>] *= <span class="number">2</span>;</span><br><span class="line">			dp[A[i]<span class="number">-1</span>][<span class="number">1</span>] += dp[A[i]<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">			dp[A[i]<span class="number">-1</span>][<span class="number">1</span>] %= mod;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[A[i]+<span class="number">1</span>][<span class="number">0</span>] *= <span class="number">2</span>;</span><br><span class="line">		dp[A[i]+<span class="number">1</span>][<span class="number">0</span>] += dp[A[i]][<span class="number">0</span>];</span><br><span class="line">		dp[A[i]+<span class="number">1</span>][<span class="number">1</span>] *= <span class="number">2</span>;</span><br><span class="line">		dp[A[i]+<span class="number">1</span>][<span class="number">1</span>] %= mod;</span><br><span class="line">		dp[A[i]+<span class="number">1</span>][<span class="number">0</span>] %= mod;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans%mod &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// IOS</span></span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></h2><h2 id="E-Crazy-Robot"><a href="#E-Crazy-Robot" class="headerlink" title="E. Crazy Robot"></a>E. Crazy Robot</h2><p><strong>题意</strong><br>给你一个N*M的图，只包含’.’  ‘#’  ‘L’  代表了空地，障碍，终点。空地放置一个坏了的机器人，你给他一个指令，他会向除了你给的方向的其他方向移动，如果无法移动他将原地不动，问你能否通过一些指令，使他到达终点。把满足的起点标位’+‘  ，再把图输出</p>
<p><strong>思路</strong><br>首先满足的空地是一个联通块。我们只需要从终点开始BFS即可。如果一个点可以走的方向小于等于1个，我们就可以控制他的走向了，具体看代码。</p>
<p><strong>代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CN puts(<span class="meta-string">&quot;NO&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CY puts(<span class="meta-string">&quot;YES&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> fact[maxn], infact[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jie_init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) fact[i] = fact[i<span class="number">-1</span>] * i % mod;	</span><br><span class="line">	infact[n] = <span class="built_in">qmi</span>(fact[n],mod<span class="number">-2</span>,mod);</span><br><span class="line">	<span class="built_in">per</span>(i,n<span class="number">-1</span>,<span class="number">0</span>) infact[i] = infact[i+<span class="number">1</span>] * (i+<span class="number">1</span>) % mod;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;<span class="keyword">return</span> fact[n] * infact[m] % mod * infact[n-m] % mod;&#125;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn],dp[maxn],f[maxn];</span><br><span class="line"></span><br><span class="line">string g[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N) cin &gt;&gt; g[i], g[i] = <span class="string">&#x27; &#x27;</span> + g[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> xx,yy;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N)</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,M)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				xx = i;</span><br><span class="line">				yy = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	map&lt;PII,<span class="keyword">int</span>&gt; st;</span><br><span class="line">	queue&lt;PII&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">mk</span>(xx,yy));</span><br><span class="line">	st[<span class="built_in">mk</span>(xx,yy)] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		PII t = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		xx = t.fi, yy = t.se;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)<span class="comment">//枚举周围的点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> tx = xx + dx[i];</span><br><span class="line">			<span class="keyword">int</span> ty = yy + dy[i];</span><br><span class="line">			<span class="keyword">if</span>(tx &gt; N || tx &lt; <span class="number">1</span> || ty &lt; <span class="number">1</span> || ty &gt; M) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(g[tx][ty] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">int</span> dir = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,<span class="number">3</span>)<span class="comment">//判断这个点符不符合</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> ttx = tx + dx[j];</span><br><span class="line">				<span class="keyword">int</span> tty = ty + dy[j];</span><br><span class="line">				<span class="comment">//不能走的点和已经确认成功的点都continue掉</span></span><br><span class="line">				<span class="keyword">if</span>(ttx &gt; N || ttx &lt; <span class="number">1</span> || tty &lt; <span class="number">1</span> || tty &gt; M) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(g[ttx][tty] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(st[<span class="built_in">mk</span>(ttx,tty)]) <span class="keyword">continue</span>;</span><br><span class="line">				dir ++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(dir &lt;= <span class="number">1</span> &amp;&amp; !st[<span class="built_in">mk</span>(tx,ty)])&#123;<span class="comment">//不确认的方向只有一个，可以用指令排除掉</span></span><br><span class="line">				<span class="comment">// cout &lt;&lt; tx &lt;&lt; &quot;tx---ty&quot; &lt;&lt; ty &lt;&lt;endl;</span></span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">mk</span>(tx,ty));</span><br><span class="line">				st[<span class="built_in">mk</span>(tx,ty)] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">1</span>,M)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(st[<span class="built_in">mk</span>(i,j)] &amp;&amp; g[i][j] == <span class="string">&#x27;.&#x27;</span>) cout &lt;&lt; <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; g[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IOS</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
  </entry>
  <entry>
    <title>P1002  [FJOI2007]轮状病毒</title>
    <url>/2022/02/21/P1002%20%20%5BFJOI2007%5D%E8%BD%AE%E7%8A%B6%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一张图，求它生成树的个数。</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>基尔霍夫矩阵树定理，用于解决无向图生成树个数的问题</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目只给了N，但是题目的图是特殊的，我们可以根据N构造出来。等价于给了一张完整的无向图。然后我们就可以通过矩阵树定理求解了。<br>高斯消元复杂度较高，但是我们可以发现递推式a[i]=a[i-1]*3-a[i-2]+2，具体推理看<a href="https://www.cnblogs.com/Parry-PY/p/7731858.html">大佬</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> maxdigit=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> len,d[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span></span>&#123;<span class="keyword">while</span>(len&gt;<span class="number">1</span> &amp;&amp; !d[len<span class="number">-1</span>]) len--;&#125;</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) s+=d[len<span class="number">-1</span>-i]+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">BigInt</span>()&#123;<span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));len=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="keyword">int</span> num)&#123;*<span class="keyword">this</span>=num;&#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="keyword">char</span>* num)&#123;*<span class="keyword">this</span>=num;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> BigInt&amp; oth)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(len!=oth.len) <span class="keyword">return</span> len&lt;oth.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(d[i]!=oth.d[i]) <span class="keyword">return</span> d[i]&lt;oth.d[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInt&amp; oth)<span class="keyword">const</span>&#123;<span class="keyword">return</span> oth&lt;*<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInt&amp; oth)<span class="keyword">const</span>&#123;<span class="keyword">return</span> !(oth&lt;*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInt&amp; oth)<span class="keyword">const</span>&#123;<span class="keyword">return</span> !(*<span class="keyword">this</span>&lt;oth);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> BigInt&amp; oth)<span class="keyword">const</span>&#123;<span class="keyword">return</span> oth&lt;*<span class="keyword">this</span> || *<span class="keyword">this</span>&lt;oth;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BigInt&amp; oth)<span class="keyword">const</span>&#123;<span class="keyword">return</span> !(oth&lt;*<span class="keyword">this</span>) &amp;&amp; !(*<span class="keyword">this</span>&lt;oth);&#125;</span><br><span class="line"> </span><br><span class="line">    BigInt <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">        len=<span class="built_in">strlen</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) d[i]=num[len<span class="number">-1</span>-i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>=(<span class="keyword">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(s,<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>=s;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInt&amp; oth)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        BigInt c;</span><br><span class="line">        c.len=<span class="built_in">max</span>(len,oth.len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=c.len;i++) c.d[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c.d[i]+=(i&lt;len?d[i]:<span class="number">0</span>)+(i&lt;oth.len?oth.d[i]:<span class="number">0</span>);</span><br><span class="line">            c.d[i+<span class="number">1</span>]+=c.d[i]/<span class="number">10</span>;</span><br><span class="line">            c.d[i]%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c.len+=(c.d[c.len]&gt;<span class="number">0</span>);</span><br><span class="line">        c.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInt&amp; oth)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        BigInt c=*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span>(c&lt;oth) <span class="built_in">printf</span>(<span class="string">&quot;Produce negative number!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;oth.len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c.d[i]-=oth.d[i];</span><br><span class="line">            <span class="keyword">if</span>(c.d[i]&lt;<span class="number">0</span>) c.d[i]+=<span class="number">10</span>, c.d[i+<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(c.d[i]&lt;<span class="number">0</span>) c.d[i++]+=<span class="number">10</span>, c.d[i]--;</span><br><span class="line">        c.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInt&amp; oth)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        BigInt c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;oth.len;j++) c.d[i+j]+=d[i]*oth.d[j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len+oth.len || !c.d[i];c.len=++i) c.d[i+<span class="number">1</span>]+=c.d[i]/<span class="number">10</span>, c.d[i]%=<span class="number">10</span>;</span><br><span class="line">        c.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>/(<span class="keyword">const</span> BigInt&amp; oth)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        BigInt c=*<span class="keyword">this</span>, r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            r=r*<span class="number">10</span>+c.d[len<span class="number">-1</span>-i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) <span class="keyword">if</span>(r&lt;oth*(j+<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            c.d[len<span class="number">-1</span>-i]=j;</span><br><span class="line">            r=r-oth*j;</span><br><span class="line">        &#125;</span><br><span class="line">        c.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>%(<span class="keyword">const</span> BigInt&amp; oth)</span><br><span class="line">    &#123;</span><br><span class="line">        BigInt r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            r=r*<span class="number">10</span>+d[len<span class="number">-1</span>-i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) <span class="keyword">if</span>(r&lt;oth*(j+<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            r=r-oth*j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>+=(<span class="keyword">const</span> BigInt&amp; oth)</span><br><span class="line">    &#123;</span><br><span class="line">        *<span class="keyword">this</span>=*<span class="keyword">this</span>+oth;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>*=(<span class="keyword">const</span> BigInt&amp; oth)</span><br><span class="line">    &#123;</span><br><span class="line">        *<span class="keyword">this</span>=*<span class="keyword">this</span>*oth;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>-=(<span class="keyword">const</span> BigInt&amp; oth)</span><br><span class="line">    &#123;</span><br><span class="line">        *<span class="keyword">this</span>=*<span class="keyword">this</span>-oth;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>/=(<span class="keyword">const</span> BigInt&amp; oth)</span><br><span class="line">    &#123;</span><br><span class="line">        *<span class="keyword">this</span>=*<span class="keyword">this</span>/oth;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, BigInt&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    in&gt;&gt;s;</span><br><span class="line">    x=s.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,<span class="keyword">const</span> BigInt&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    out&lt;&lt;x.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">BigInt f[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	</span><br><span class="line">	f[<span class="number">1</span>] = <span class="number">1</span>, f[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=N;i++) f[i]=(f[i<span class="number">-1</span>]*<span class="number">3</span>-f[i<span class="number">-2</span>]+<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;f[N]&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
  </entry>
  <entry>
    <title>codeforces 746</title>
    <url>/2021/10/04/codeforces-746/</url>
    <content><![CDATA[<h3 id="A-Gamer-Hemose"><a href="#A-Gamer-Hemose" class="headerlink" title="A. Gamer Hemose"></a>A. Gamer Hemose</h3><p><strong>题意：</strong>你有n个士兵，攻击力是ai，每个士兵攻击次数不限但不能连续攻击，最少几次能把血量为H的怪物杀死。</p>
<p><strong>思路：</strong>由于不能连续攻击，我们让攻击力最大和第二大的士兵轮流攻击就好了。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	iocin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,x);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line">vi G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">		<span class="comment">// int mmax = 0;</span></span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N) &#123;</span><br><span class="line">			cin &gt;&gt; A[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(A+<span class="number">1</span>,A+<span class="number">1</span>+N);</span><br><span class="line">		<span class="keyword">int</span> X = A[N]+A[N<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">int</span> ans = M/X*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(M%X)&#123;</span><br><span class="line">			<span class="keyword">if</span>((M%X)&gt;A[N]) ans+=<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">else</span> ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">wtl</span>(ans);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="B-Hemose-Shopping"><a href="#B-Hemose-Shopping" class="headerlink" title="B. Hemose Shopping"></a>B. Hemose Shopping</h3><p><strong>题意：</strong>看能否将给定数组排序。方法为交换下标差大于等于X的两个元素。</p>
<p><strong>思路：</strong>若该位置可以交换，则该位置上的元素一定可以换到对应位置；若该位置无法交换，则检查该位置上的元素是否在正确位置，若不在则否。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	iocin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,x);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> A[maxn];</span><br><span class="line"><span class="keyword">int</span> B[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line">vi G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">			cin &gt;&gt; A[i];</span><br><span class="line">      B[i] = A[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(B+<span class="number">1</span>,B+<span class="number">1</span>+N);</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">      <span class="keyword">if</span>(A[i]==B[i]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(i<span class="number">-1</span>&lt;M&amp;&amp;N-i&lt;M) f = <span class="number">0</span>;<span class="comment">//不能动的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h3 id="C-Bakry-and-Partitioning"><a href="#C-Bakry-and-Partitioning" class="headerlink" title="C. Bakry and Partitioning"></a>C. Bakry and Partitioning</h3><p><strong>题意：</strong>给你一棵树和各点的权值，给你一个K，通过去边将这棵树分成【2，K-1】个部分，各部分点权异或和相等。</p>
<p><strong>思路：</strong></p>
<ol>
<li><p>从k分类讨论（K&gt;=2）</p>
<ul>
<li>当K等于2时只能分成两部分，又因为两部分的异或和相等，所以总的异或和一定为0。</li>
<li>当K&gt;=3时我们我们分成3部分，因为任意两个相同的可以合并成0，我们只要dfs找到两部分异或和分别为全部的异或和即可。</li>
</ul>
</li>
<li><p>从全部异或和xosum讨论</p>
<pre><code> - xosum等于0，以定位YES，因为一定可以分成两部分相同的。
 - xosum不等于0则要求K!=2，因为至少分成3份；而且dfs同样要至少两部分异或和邓异xosum。
</code></pre></li>
</ol>
<p><strong>代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	iocin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,x);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line">vi G[maxn];</span><br><span class="line"><span class="keyword">int</span> xosum = <span class="number">0</span>,cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> to = G[u][i];</span><br><span class="line">		<span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(to,u);</span><br><span class="line">		A[u]^=A[to];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(A[u]==xosum)&#123;</span><br><span class="line">		A[u] = <span class="number">0</span>;</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	iocin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		iocin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">		xosum = <span class="number">0</span>;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">			iocin &gt;&gt; A[i];</span><br><span class="line">			xosum^=A[i];</span><br><span class="line">			G[i].<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> u,v;</span><br><span class="line">			iocin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			G[u].<span class="built_in">pb</span>(v);</span><br><span class="line">			G[v].<span class="built_in">pb</span>(u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(xosum==<span class="number">0</span>)&#123; </span><br><span class="line">		    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">		    <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(M&gt;=<span class="number">3</span>&amp;&amp;cnt&gt;=<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>namomo week1</title>
    <url>/2022/02/28/namomo%20week1/</url>
    <content><![CDATA[<h1 id="题单"><a href="#题单" class="headerlink" title="题单"></a><a href="https://vjudge.net/contest/483210">题单</a></h1><h1 id="A-Crystalfly"><a href="#A-Crystalfly" class="headerlink" title="A - Crystalfly"></a>A - Crystalfly</h1><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a><strong>题意</strong></h3><p>给你一棵树，每个点上有a[i]个蝴蝶，当你走到u点，与u相邻的v的蝴蝶会在t[v]秒之后被惊动逃走（但是v的儿子不会被惊动），问你最多能抓到几只蝴蝶。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>可以注意到t数组的范围是1&lt;= t &lt;= 3，我们跟据t把u的儿子分为三类。第一秒可以选三类中的任意一个，第二秒可以选择继续走第一秒选择的儿子，或者是回到u，但是此时第三秒只能走t=3的那个儿子了（一来一回过去了2秒，t小于3的蝴蝶都被惊动飞走了,而往第一秒选择的儿子走显然不是最优）。<br>这两类行走方案如下<br><img src="/upload/2022/02/image-a2f2948ff89345e8a3e1429c4135acb8.png" alt="image.png"><br><img src="/upload/2022/02/image-5b2d036624f841cc9af43222cd206d8b.png" alt="image.png"></p>
<p>我们先不管根结点u抓不抓得到<br>定义</p>
<ul>
<li>dp[i][0]代表i不选并且所有儿子已经不能再抓了的最大值（就是两种路线取最大值）</li>
<li>dp[i][1]代表i选并且所有儿子已经不能再抓了的最大值</li>
<li>dp[i][2]代表i不选并且所有儿子都不选且已经不能再抓了的最大值</li>
</ul>
<ol>
<li>第一张图<ul>
<li>我们选择第一个儿子，其他儿子都不选，所以dp[u][0] = sum{dp[son][0]} 加上a最大的一个儿子</li>
<li>dp[u][2]相比于此时的dp[u][0]差别在于少加一个a最大的儿子</li>
</ul>
</li>
<li>第二张图<ul>
<li>我们枚举那些可以二次拯救的点（即t=3的点），假设所有点的贡献都是dp[i][0],就是sum{dp[son][0]}，就是dp[u][2]，然后拯救的点（第三步走的点）j的a[j]可以加上。对于每个点v变成第一步走的点贡献变化是a[v] + dp[v][2] - dp[v][0]，显然我们要选变化最大的点走第一步，但是这个点可能和我们枚举的拯救的点是同一点，所以我们要记录变化前二大的点(判断点是否是同一个点，所以还要记录点的编号)。</li>
<li>由此dp[u][0] = max(dp[u][0],dp[u][2] + a[j] + (c[0].second == j ? c[1].first : c[0].first))</li>
</ul>
</li>
</ol>
<p>最后dp[u][1] = dp[u][0] + a[u]</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"><span class="keyword">int</span> e[maxn],w[maxn],ne[maxn],h[maxn],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(maxn)</span>,<span class="title">t</span><span class="params">(maxn)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">3</span>,vector&lt;<span class="keyword">int</span>&gt;(maxn));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	dp[<span class="number">0</span>][u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> max_son = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> son_num = <span class="number">0</span>;</span><br><span class="line">	vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; c = &#123;<span class="built_in">make_pair</span>(<span class="number">-1e18</span>,<span class="number">0ll</span>), <span class="built_in">make_pair</span>(<span class="number">-1e18</span>,<span class="number">0ll</span>),<span class="built_in">make_pair</span>(<span class="number">-1e18</span>,<span class="number">0ll</span>)&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = e[i];</span><br><span class="line">		<span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">		son_num++;</span><br><span class="line">		<span class="built_in">dfs</span>(j, u);</span><br><span class="line">		max_son = <span class="built_in">max</span>(max_son, a[j]);</span><br><span class="line">		dp[<span class="number">0</span>][u] += dp[<span class="number">0</span>][j];</span><br><span class="line">		c[<span class="number">2</span>] = <span class="built_in">make_pair</span>(a[j] + dp[<span class="number">2</span>][j] - dp[<span class="number">0</span>][j],j);</span><br><span class="line">		<span class="built_in">sort</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>(),[&amp;](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; aa, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; bb) &#123;</span><br><span class="line">			<span class="keyword">if</span> (aa.first != bb.first) &#123;</span><br><span class="line">				<span class="keyword">return</span> aa.first &gt; bb.first;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> aa.second &lt; bb.second;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> temp = dp[<span class="number">0</span>][u];</span><br><span class="line">	dp[<span class="number">2</span>][u] = dp[<span class="number">0</span>][u];</span><br><span class="line">	dp[<span class="number">0</span>][u] = dp[<span class="number">0</span>][u] + max_son;<span class="comment">//找个最大儿子进，其他县摆烂</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// if (son_num &gt; 1) &#123;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = e[i];</span><br><span class="line">		<span class="keyword">if</span> (j == fa || t[j] != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//回首套的点</span></span><br><span class="line">		dp[<span class="number">0</span>][u] = <span class="built_in">max</span>(dp[<span class="number">0</span>][u], temp + a[j] + (c[<span class="number">0</span>].second == j ? c[<span class="number">1</span>].first : c[<span class="number">0</span>].first));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	</span><br><span class="line">	dp[<span class="number">1</span>][u] = dp[<span class="number">0</span>][u] + a[u];</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	idx = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(N+<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cin &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cin &gt;&gt; t[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		<span class="built_in">add</span>(u, v);</span><br><span class="line">		<span class="built_in">add</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">	cout &lt;&lt; dp[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="B-Towers"><a href="#B-Towers" class="headerlink" title="B - Towers"></a>B - Towers</h1><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a><strong>题意</strong></h3><p>给你一棵树，每个点的权值为a[i]，现在要求你给每个点的e[i]赋值，使得<strong>每个点</strong>都存在两个点u，v，这个点在u，v的简单路径上，且e[u]&gt;=a[i]且e[v]&gt;=a[i]。求所有e[i]的和（e[i] &gt;= 0）</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>我们首先找到权值最大的点root，以它为根。因为根最大，肯定有两个点的e是a[root]是专门用来满足root的。这样对于除了根以外的所有点i都可以从上述两个点其中一个到根再到i，这样来获得u，v的其中一个。而另一个一定是在i的子树当中(包括i本身)。如果子树的最大值大于等于a[i]了，那么e[i]=0,不需要额外开销；如果子树的最大值小于a[i],我们则需要把最大值补成a[i]，开销是a[i]-max。</p>
<p>因为要先知道子树中的最大值，所以我们先递归到叶子结点，在回溯时从下往上处理。</p>
<p>当回溯到根的时候，因为我们一开始是设了两个点的e等于a[root]的，他们应该在root不同的儿子里，要不然就不是简单路径了。所以我们把root的每个儿子的子树的最大值存起来，取前两个大的补成a[root]。</p>
<p>但是root可能只有一个儿子，那么我们只需要把e[root]设为a[root]</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-keyword">error</span>(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e[maxn],w[maxn],ne[maxn],h[maxn],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(maxn)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; mmax;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = e[i];</span><br><span class="line">		<span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="built_in">dfs</span>(j, u);</span><br><span class="line">		mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">		<span class="keyword">if</span> (u == root) &#123;</span><br><span class="line">			mmax.<span class="built_in">push_back</span>(-t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (u == root) &#123;</span><br><span class="line">		<span class="built_in">sort</span>(mmax.<span class="built_in">begin</span>(),mmax.<span class="built_in">end</span>());</span><br><span class="line">		ans += <span class="built_in">max</span>(<span class="number">0ll</span>,a[root] + mmax[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> (mmax.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			ans += a[root];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> ans += <span class="built_in">max</span>(<span class="number">0ll</span>,a[root] + mmax[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mx &lt; a[u]) &#123;</span><br><span class="line">		ans += a[u] - mx;</span><br><span class="line">		mx = a[u];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(N+<span class="number">10</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cin &gt;&gt; a[i];</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		<span class="built_in">add</span>(u, v);</span><br><span class="line">		<span class="built_in">add</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; a[root]) &#123;</span><br><span class="line">			root = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(root,<span class="number">-1</span>);	</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="C-Werewolves"><a href="#C-Werewolves" class="headerlink" title="C - Werewolves"></a>C - Werewolves</h1><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a><strong>题意</strong></h3><p>给你一棵树，每个点都有一个颜色，问你某种颜色数量<strong>严格大于联通块大小一半</strong>的联通块数量。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a><strong>思路</strong></h3><ul>
<li>数量严格大于大小的一半，说明每个合法的联通块都对应着一个颜色，那么我们可以枚举颜色，把每种颜色的合法联通块累加起来就是总的答案。</li>
<li>对于一个颜色color，我们把颜色是color的权值设为1，不同的设为-1，这样就把问题转化为总的权值大于0的联通块个数，就是一个树上背包问题。</li>
<li>普通的树上背包复杂度是O(N2),再加上颜色数最后是O(N3)。但是有些状态我们是不需要枚举的，就是权值和的范围最大是[-cnt[color],cnt[color]]，这样复杂度分摊是O(N2)</li>
<li>权值有负的，我们可以加上一个偏移值base</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a><strong>代码</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-keyword">error</span>(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[<span class="number">3030</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	G[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">3010</span>,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">6010</span>));</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">3030</span>)</span>, <span class="title">siz</span><span class="params">(<span class="number">3007</span>)</span>, <span class="title">f</span><span class="params">(<span class="number">6060</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">3030</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> color;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> base = <span class="number">3005</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	siz[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (color == a[u]) dp[u][base+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> dp[u][base - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j : G[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(j, u);</span><br><span class="line">		<span class="keyword">int</span> bro1 = <span class="built_in">min</span>(siz[u], num[color]);<span class="comment">//之前枚举过的子树</span></span><br><span class="line">		<span class="keyword">int</span> bro2 = <span class="built_in">min</span>(siz[j], num[color]);<span class="comment">//当前子树</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = -bro1; x &lt;= bro1; x ++) &#123;</span><br><span class="line">			f[x + base] = dp[u][x + base];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当前子树和之前的子树配对（方案相乘）</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = -bro1; x &lt;= bro1; x ++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> y = -bro2; y &lt;= bro2; y ++) &#123;</span><br><span class="line">				(dp[u][x + y + base] += dp[j][y + base] * f[x + base]) %= mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		siz[u] += siz[j];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num[color]; i ++) &#123;<span class="comment">//累加颜色为color，祖先是u的合法联通块</span></span><br><span class="line">		(ans += dp[u][i + base]) %= mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cin &gt;&gt; a[i], num[a[i]] ++;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		<span class="built_in">add</span>(u, v);</span><br><span class="line">		<span class="built_in">add</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//清空初始化</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= N; u ++ ) </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = -num[i]; j &lt;= num[i]; j ++)</span><br><span class="line">            	dp[u][j + base] = <span class="number">0</span>;</span><br><span class="line">		color = i;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="D-Paint"><a href="#D-Paint" class="headerlink" title="D - Paint"></a>D - Paint</h1><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给你N个数，每次你能选择数值相同的一段把它变成另外一个数值，问把这N个数全部变成一个颜色需要多少次操作。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>首先我们把原数组相邻的相同元素进行压缩，压缩后有M个元素</p>
<p>那么我们最多只需要M-1次操作之后所有元素值相同</p>
<p>对于abc当a=c（两端相等）时我们可以减少一次操作</p>
<p>我们定义dp[i][j]代表区间[i,j]最多可以减少几次操作，那么最后答案就是M-1-dp[1][M]</p>
<p>转移方程dp[i][j] = dp[i][j-1],dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j-1]+1),k满足k&gt;=i，且a[k]==a[j].对于k直接枚举区间[i,j]会超时，题目保证每个数最多出现20次，我们只需要预处理出上一个等于a[i]的位置的pre[i]就能保证k最多枚举20次，复杂度为20<em>N</em>N。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-keyword">error</span>(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N + <span class="number">1</span>)</span>,<span class="title">nxt</span><span class="params">(N+<span class="number">1</span>)</span>, b</span>;</span><br><span class="line">	b.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; a[i] != a[i<span class="number">-1</span>]) &#123;</span><br><span class="line">			b.<span class="built_in">push_back</span>(a[i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	b.<span class="built_in">push_back</span>(a[N]);</span><br><span class="line">	M = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(N+<span class="number">10</span>)</span>, <span class="title">st</span><span class="params">(N+<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!st[b[i]]) &#123;</span><br><span class="line">			pre[i] = <span class="number">0</span>;</span><br><span class="line">			st[b[i]] = i;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre[i] = st[b[i]];</span><br><span class="line">			st[b[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;<span class="built_in">dp</span>(N+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(N+<span class="number">1</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= M; len ++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= M; i ++) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (b[i] == b[j]) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">int</span> x = pre[j];</span><br><span class="line">				<span class="keyword">while</span> (x &gt;= i) &#123;</span><br><span class="line">					dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][x] + dp[x + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">					x = pre[x];</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; M - <span class="number">1</span> - dp[<span class="number">1</span>][M] &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="E-Outer-space-invaders"><a href="#E-Outer-space-invaders" class="headerlink" title="E - Outer space invaders"></a>E - Outer space invaders</h1><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>有N个敌人，每个人出现的时间是a[i]到b[i],出现的位置在d[i]，你只能在原点放置炸弹，威力为r的炸弹需要r花费，能炸到[-r,r]，问消灭所有敌人的最小花费。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于每个敌人我们可以表示成一个平行于x轴的线段，高度为d，这样题目就变成了最少需要多长的竖直线段，能穿过所有线段。<br><img src="/upload/2022/03/image-1a16ab2bb9ff440b8f87d5a6bcb0df14.png" alt="image.png"></p>
<ul>
<li>首先，对于最高的线段，必然有一条红线等于它的高度来消灭它，在消灭它的同时可以借机消灭其他较矮的线段。</li>
<li>dp[i][j]代表消灭区间[i,j]内的所有敌人所需要最小花费。</li>
<li>我们找到当前区间的d最大的线段，然后枚举线段上的每一点i，把区间分为了两部分[l,i-1]和[i+1,r]。</li>
<li>如果线段不是真包涵于当前区间，说明它被某个区间的分界线隔断了，而区间的分界线就是有炸弹的时刻。</li>
<li>dp[l][r] = min(dp[l][i-1] + dp[i+1][r]) + d[i]</li>
</ul>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-keyword">error</span>(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(maxn)</span>, <span class="title">b</span><span class="params">(maxn)</span>, <span class="title">d</span><span class="params">(maxn)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">1010</span>,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">1010</span>));</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (dp[l][r] != <span class="number">-1</span>) <span class="keyword">return</span> dp[l][r];</span><br><span class="line">	<span class="keyword">int</span> &amp;ans = dp[l][r];</span><br><span class="line">	ans = INF;</span><br><span class="line">	pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mx = &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt;= l &amp;&amp; b[i] &lt;= r) &#123;</span><br><span class="line">			<span class="keyword">if</span> (d[i] &gt; mx.first) &#123;</span><br><span class="line">				mx = &#123;d[i], i&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (mx.first == <span class="number">-1</span>) <span class="keyword">return</span> ans = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = a[mx.second]; i &lt;= b[mx.second]; i ++) &#123;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, <span class="built_in">dfs</span>(l,i<span class="number">-1</span>) + <span class="built_in">dfs</span>(i+<span class="number">1</span>,r));</span><br><span class="line">	&#125;</span><br><span class="line">	ans += mx.first;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; d[i];</span><br><span class="line">		v.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">		v.<span class="built_in">push_back</span>(b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">	v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()),v.<span class="built_in">end</span>());</span><br><span class="line">	M = v.<span class="built_in">size</span>();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		a[i] = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),a[i]) - v.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">		b[i] = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),b[i]) - v.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line">			dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>,M) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo camp</category>
      </categories>
  </entry>
  <entry>
    <title>namomo week2</title>
    <url>/2022/03/06/namomo%20week2/</url>
    <content><![CDATA[<h1 id="题单"><a href="#题单" class="headerlink" title="题单"></a><a href="https://vjudge.net/contest/483210#overview">题单</a></h1><h1 id="F-Infinite-Set"><a href="#F-Infinite-Set" class="headerlink" title="F - Infinite Set"></a>F - Infinite Set</h1><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一些数a[i]，你可以得到a[i]<em>2+1和a[i]</em>4，问能得到多少个小于2的p次方的数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>对于一个数它可能是由另一个较小数转变过来，所以我们需要这两个数是否能由另一个转化而来。</li>
<li>我们来看两种操作的变化<ul>
<li>a[i]*2+1，二进制末尾加个1</li>
<li>a[i]*4，二进制末尾加2个0</li>
</ul>
</li>
<li><p>根据操作的变化我们看大的数能否回退到较小的a[i]，如果能当前数不插入</p>
</li>
<li><p>2的p次二进制是1后面p个0，所以小于它的数 长度小于等于p</p>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span> <span class="params">(N)</span></span>;</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		<span class="comment">// cin &gt;&gt; a[i];</span></span><br><span class="line">		<span class="keyword">int</span> x = a[i];</span><br><span class="line">		<span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(a[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s.<span class="built_in">count</span>(a[i])) &#123;</span><br><span class="line">				f = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (a[i] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				a[i] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &amp; <span class="number">3</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				a[i] &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!f) &#123;</span><br><span class="line">			s.<span class="built_in">insert</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">30</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(max(M+<span class="number">1</span>,<span class="number">100ll</span>),<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : s) &#123;</span><br><span class="line">		cnt[__lg(x)] ++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">30</span>) dp[i] = cnt[i] % mod;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; <span class="number">0</span>) (dp[i] += dp[i<span class="number">-1</span>])%=mod;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; <span class="number">1</span>) (dp[i] += dp[i<span class="number">-2</span>])%=mod;</span><br><span class="line">		(ans += dp[i]) %= mod;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="G-Namomo-Subsequence"><a href="#G-Namomo-Subsequence" class="headerlink" title="G - Namomo Subsequence"></a>G - Namomo Subsequence</h1><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给你一个字符串，问你有几个子序列满足namomo的形式。<br>N是<strong>1e6</strong></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li>显然momo的限制更强一些，如果我们知道了momo的子序列个数只要乘上后面不同于m和o的两个不同的字母的组合（n，a）个数即可。</li>
</ul>
<ol>
<li>对于两个字母的组合有多少种有个《初中数学》可以O（1）求得。<ul>
<li>记剩下每个字母i的个数是cnt[i]，则不同字母的组合数是（cnt[1] + cnt[2] + … + cnt[k]）^ 2 - (cnt[1] ^ 2 + cnt[2] ^ 2 + .. + cnt[k] ^ 2) / 2。</li>
<li>n，a不能和m，o相同，计算时只需要把cnt[m]和cnt[o]有关的去掉就好了。</li>
<li>维护sum1是剩余字母个数，sum2是每个字母个数平方和。sum1每次减一，sum2 - （cnt <em> cnt） + ((cnt - 1) </em> (cnt - 1))，化简之后就是sum2 -= 2 * cnt - 1。算完sum2后再把当前字母的cnt—。</li>
</ul>
</li>
<li>我们可以dp求形如momo的子序列个数。<ul>
<li>定义dp[i][j][k]为匹配了momo的第i个位置，第i个位置是k，前一个是j。c[a]是目前为止字符a出现的次数。</li>
<li>转移方程<ul>
<li>dp[2][j][a[i]] += c[j]</li>
<li>dp[3][j][a[i]] += dp[2][a[i]][j]</li>
<li>c[a[i]] ++<br>-计算当前位置作为最后一位（第四位）的贡献，num_momo = dp[3][a[i]][j], num_na = ((sum1 - c[a[i]] - c[j]) <em> (sum1 - c[a[i]] - c[j]) - (sum2 - c[a[i]] </em> c[a[i]] - c[j] <em> c[j])) / 2 % mod。贡献为num_momo </em> num_na。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">    cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">char</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> (s - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> (s - <span class="string">&#x27;A&#x27;</span> + <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s &lt;= <span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> (s - <span class="string">&#x27;a&#x27;</span> + <span class="number">37</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll dp[<span class="number">10</span>][<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    N = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">        a[N - i - <span class="number">1</span>] = <span class="built_in">cal</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll sum1 = N, sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">        c[a[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">63</span>; i ++) &#123;</span><br><span class="line">        sum2 += c[i] * c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">        sum1 --;</span><br><span class="line">        sum2 -= <span class="number">2</span> * c[a[i]] - <span class="number">1</span>;</span><br><span class="line">        c[a[i]] --;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">63</span>; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == a[i]) <span class="keyword">continue</span>;</span><br><span class="line">            (dp[<span class="number">2</span>][j][a[i]] += cnt[j]) %= mod;</span><br><span class="line">            (dp[<span class="number">3</span>][j][a[i]] += dp[<span class="number">2</span>][a[i]][j]) %= mod;</span><br><span class="line"></span><br><span class="line">            ll pre = dp[<span class="number">3</span>][a[i]][j];</span><br><span class="line">            ll af = ((sum1 - c[a[i]] - c[j]) * (sum1 - c[a[i]] - c[j]) - (sum2 - c[a[i]] * c[a[i]] - c[j] * c[j])) / <span class="number">2</span> % mod;</span><br><span class="line">            (ans += pre * af) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[a[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="H-Damaged-Bicycle"><a href="#H-Damaged-Bicycle" class="headerlink" title="H - Damaged Bicycle"></a>H - Damaged Bicycle</h1><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给你一张N个点，M条边的图，其中K个点有共享单车，每辆单车有p[i]的概率是坏的。走路的速度是t，骑车的速度是r。问你从1号点走到N号点的最小期望时间是多少。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul>
<li>生活常识，骑车的速度比走路快，所以为了时间最小，一旦我们成功骑到车我们将沿着最短路走到终点。而在此之前我们都是走路。</li>
<li>走的路全部都是最短路，所以我们要预处理起点，终点，有车点到其他点的最短路。</li>
<li>用dp[S][i]状压代表S二进制中1的单车都坏了的情况下当前在i到终点还需要的时间的最小期望。</li>
<li>转移方程<ol>
<li>车是好的，直接骑到终点。t_car</li>
<li>车是坏的<ul>
<li>走到还没确认好坏的车那里</li>
<li>走路到终点</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>答案是1+min（2）</p>
<ul>
<li>dp[s][i] = dp[s | (1 &lt;&lt; j)][j] + d[i][j] / v_walk;</li>
<li>最后枚举在哪个点扫到车就好了，时间是d[k][i] / t_walk + dp[1&lt;&lt;i][i];</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e[maxm],w[maxm],ne[maxm],h[maxn],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(maxn+<span class="number">7</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	dis[u] = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; , vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;&gt; heap;</span><br><span class="line">	heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, u&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dis[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">20</span>][<span class="number">18</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(maxn));</span><br><span class="line">	<span class="keyword">int</span> t, r;</span><br><span class="line">	cin &gt;&gt; t &gt;&gt; r;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, w;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		<span class="built_in">add</span>(u, v, w);</span><br><span class="line">		<span class="built_in">add</span>(v, u, w);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; K;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(K + <span class="number">2</span>)</span>, <span class="title">p</span><span class="params">(K)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i] &gt;&gt; p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a[K] = <span class="number">1</span>;</span><br><span class="line">	a[K + <span class="number">1</span>] = N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K + <span class="number">2</span>; i ++) &#123;</span><br><span class="line">		<span class="built_in">dijkstra</span>(a[i]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K + <span class="number">2</span>; j ++) &#123;</span><br><span class="line">			d[i][j] = dis[a[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (d[K][K + <span class="number">1</span>] == INF) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> S = (<span class="number">1</span> &lt;&lt; K) - <span class="number">1</span>; S &gt;= <span class="number">0</span>; S --) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i ++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((S &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">double</span> pbad = <span class="number">0.01</span> * p[i];</span><br><span class="line">				<span class="keyword">double</span> t_car = <span class="number">1.</span> * d[i][K + <span class="number">1</span>] / r;<span class="comment">//开车到终点</span></span><br><span class="line">				<span class="keyword">double</span> t_walk = <span class="number">1.</span> * d[i][K + <span class="number">1</span>] / t;<span class="comment">//走路到终点</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j ++) &#123;</span><br><span class="line">					<span class="keyword">if</span> ((S &gt;&gt; j) &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">					t_walk = <span class="built_in">min</span>(t_walk, <span class="number">1.</span> * d[i][j] / t + dp[S | (<span class="number">1</span> &lt;&lt; j)][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				dp[S][i] = pbad * t_walk + (<span class="number">1</span> - pbad) * t_car;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> ans = <span class="number">1.</span> * d[K][K + <span class="number">1</span>] / t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i ++) &#123;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, <span class="number">1.</span> * d[K][i] / t + dp[<span class="number">1</span> &lt;&lt; i][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.7lf&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="I-Game-on-Sum-Easy-Version"><a href="#I-Game-on-Sum-Easy-Version" class="headerlink" title="I - Game on Sum (Easy Version)"></a>I - Game on Sum (Easy Version)</h1><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>Alice和Bob玩游戏，游戏一共会进行n轮，有一个数s表示总和。每一轮Alice会选择一个0到k之间的实数，Bob选择把它加到s上面或者从s中退减去。Bob至少要选择m次加法。<br>Bob希望最后的总和尽量小，Alice希望最后的总和尽量大。问两个人都按最优策略，答案是多少。<br>n &lt; 2000</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>先不要管k，只需要靠虑k=1，最后答案乘以k就好</p>
<p>正着想很乱，会无限递归到最后，所以我们反着想。</p>
<p>dp[i][j]表示还有i局，bob还要至少加j次</p>
<p>显然</p>
<ul>
<li>dp[i][0] = 0，因为bob希望总和最小所以他会无脑减，所以Alice每次都选0</li>
<li>dp[i][i] = i，因为bob只能加了，所以Alice每次都选1</li>
</ul>
<p>由此，我们可以递推</p>
<ul>
<li><p>Alice选择x，bob选择减，dp[i][j] = dp[i - 1][j] - x</p>
</li>
<li><p>Alice选择x，bob选择加，dp[i][j] = dp[i - 1][j - 1] + x</p>
</li>
</ul>
<p>因为Alice先选数，所以bob总是选择较小的，所以Alice选择的x使得bob不管加减都相等，即x = (dp[i - 1][j] - dp[i - 1][j - 1]) / 2。</p>
<p>所以 dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) / 2。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); cout &lt;&lt; <span class="meta-string">&quot;\n&quot;</span>&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">norm</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x += P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= P) &#123;</span><br><span class="line">        x -= P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">power</span><span class="params">(T a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    T res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Z</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">Z</span>(<span class="keyword">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    Z <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="built_in">norm</span>(P - x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">inv</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, P - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">i64</span>(x) * rhs.x % P;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>/=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>*(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>+(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>-(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>/(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;vector&lt;Z&gt;&gt; <span class="built_in">dp</span>(<span class="number">2001</span>,vector&lt;Z&gt;(<span class="number">2001</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;</span><br><span class="line">	Z ans = dp[N][M] * K;</span><br><span class="line">	cout &lt;&lt; ans.<span class="built_in">val</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2000</span>; i ++) &#123;</span><br><span class="line">		dp[i][i]  = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++) &#123;</span><br><span class="line">			dp[i][j] = (dp[i<span class="number">-1</span>][j] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="J-Game-on-Sum-Hard-Version"><a href="#J-Game-on-Sum-Hard-Version" class="headerlink" title="J - Game on Sum (Hard Version)"></a>J - Game on Sum (Hard Version)</h1><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>和简单版相比n的范围变大了   n &lt; 1000000</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>转移方程像是杨辉三角，dp[i][j]的贡献会传到dp[i+1][j]和dp[i+1][j+1]，即往下或者右下走。</p>
<p>二所有有贡献的点是dp[i][i]，(i,i)走到(N,M)需要向下走N-i步，其中有M-i步往右下走。由于第一步走右下是(i+1,i+1)，这一步的不是转移过来的，所以第一步只能往下走，所以(i,i)走到(N,M)的路径有C(N - i - 1, M - i)种。</p>
<p>根据递推式，没往下走一步都要除以2，所以还要除以2^(N - i)</p>
<p>最后答案是K <em> C(N - i - 1, M - i) </em> i / pow(2, N - i)（1 &lt;= i &lt;= M）;</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); cout &lt;&lt; endl;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">norm</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x += P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= P) &#123;</span><br><span class="line">        x -= P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">power</span><span class="params">(T a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    T res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Z</span> &#123;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">Z</span>(<span class="keyword">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    Z <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="built_in">norm</span>(P - x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">inv</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, P - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">i64</span>(x) * rhs.x % P;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>/=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>*(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>+(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>-(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>/(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Z&gt; <span class="title">fac</span><span class="params">(maxn + <span class="number">1</span>)</span>, <span class="title">invfac</span><span class="params">(maxn + <span class="number">1</span>)</span>, <span class="title">inv</span><span class="params">(maxn + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;</span><br><span class="line">	<span class="keyword">if</span> (N == M) &#123;</span><br><span class="line">		Z ans = (N * K) % mod;</span><br><span class="line">		cout &lt;&lt; ans.<span class="built_in">val</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//dp[i][i] = i, dp[i][0] = 0</span></span><br><span class="line">	<span class="comment">//考虑每个dp[i][i]对dp[n][m]的贡献</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> combine = [&amp;](<span class="keyword">int</span> n, <span class="keyword">int</span> m) &#123;</span><br><span class="line">		<span class="keyword">if</span> (m &gt; n || m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> fac[n] * invfac[m] * invfac[n - m];</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	Z ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++) &#123;</span><br><span class="line"></span><br><span class="line">		Z temp = <span class="built_in">qmi</span>(<span class="number">2</span>,N-i,mod);<span class="comment">//每到下一层都要除以二</span></span><br><span class="line">		Z x = i;</span><br><span class="line">		ans = ans + <span class="built_in">combine</span>(N - i - <span class="number">1</span>,(M - i)) / temp * x;<span class="comment">//第一次只能往下。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; ans.val() &lt;&lt; endl;</span></span><br><span class="line">	Z k = K;</span><br><span class="line">	ans = ans * k;</span><br><span class="line">	cout &lt;&lt; ans.<span class="built_in">val</span>() &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++) &#123;</span><br><span class="line">	    fac[i] = fac[i - <span class="number">1</span>] * i;</span><br><span class="line">	&#125;</span><br><span class="line">	invfac[maxn] = fac[maxn].<span class="built_in">inv</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = maxn; i; i--) &#123;</span><br><span class="line">	    invfac[i - <span class="number">1</span>] = invfac[i] * i;</span><br><span class="line">	    inv[i] = invfac[i] * fac[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo camp</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week1-day2 - daimayuanoj437. no crossing</title>
    <url>/2022/02/27/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week1-day2%20-%20daimayuanoj437.%20no%20crossing/</url>
    <content><![CDATA[<h1 id="no-crossing传送门"><a href="#no-crossing传送门" class="headerlink" title="no crossing传送门"></a>no crossing<a href="http://oj.daimayuan.top/problem/437">传送门</a></h1><p><strong>题意：</strong> 给你一个有向图，但是不用把它看成一个图，就看成数轴上的点，某些点之间有连边，注意是有向边。这样子限制条件就变成了如果这条边的中间某个点已经走过则无法选择这条边包括左右端点。在限制下求刚好经过K个点的所有路径中的最短路，如果不存在这样的最短路则输出-1.</p>
<h1 id="思路1-区间DP"><a href="#思路1-区间DP" class="headerlink" title="思路1 - 区间DP"></a><strong>思路1 - 区间DP</strong></h1><p>首先，后续每一步的区间是逐渐减小的，那么我们反着思考倒着走，那么已走的区间是不断扩大的。假如最后一步是2 -&gt; 3,那么倒数第二步一定是a -&gt; 2，a属于[1,2)和(3,N]，只有这样才符合限制。如果a属于[2,3]，那么最后一步2 -&gt; 3经过a不符合限制。</p>
<ul>
<li>我们定义dp[l][r][step][type]代表当前走过的点的左右边界（最小值，最大值），已经走了几步，当前停留在l还是r，0在l，1在r。</li>
<li>当我们倒着走时，新加入的点一定是会更新左右边界的，也就是说我们总是停在左右边界其中一个上。</li>
</ul>
<p><strong>具体看代码</strong></p>
<p><strong>代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">102</span>][<span class="number">102</span>][<span class="number">102</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">	<span class="built_in">memset</span>(mp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mp));</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; K &gt;&gt; M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b, c;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		mp[a][b] = <span class="built_in">min</span>(mp[a][b], c);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) </span><br><span class="line">		dp[i][i][<span class="number">1</span>][<span class="number">0</span>] = dp[i][i][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//只有一个点没有边答案是0</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">2</span>; step &lt;= K; step ++) &#123; <span class="comment">//步数是一步步增加的放最外面</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= N; len ++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= N; i ++) &#123;</span><br><span class="line">				<span class="keyword">int</span> j = i + len - <span class="number">1</span>;<span class="comment">//[i,j]枚举区间</span></span><br><span class="line">		 		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; i; k ++) &#123;<span class="comment">//k在i左边</span></span><br><span class="line">		 			<span class="comment">//k -&gt; i -&gt; j</span></span><br><span class="line">		 			<span class="keyword">if</span> (mp[k][i] != INF) dp[k][j][step][<span class="number">0</span>] = <span class="built_in">min</span>(dp[k][j][step][<span class="number">0</span>], dp[i][j][step<span class="number">-1</span>][<span class="number">0</span>] + mp[k][i]);</span><br><span class="line">		 			<span class="comment">//k -&gt; j -&gt; i</span></span><br><span class="line">		 			<span class="keyword">if</span> (mp[k][j] != INF) dp[k][j][step][<span class="number">0</span>] = <span class="built_in">min</span>(dp[k][j][step][<span class="number">0</span>], dp[i][j][step<span class="number">-1</span>][<span class="number">1</span>] + mp[k][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= N; k ++) &#123;<span class="comment">//k在右边</span></span><br><span class="line">					<span class="comment">//k -&gt; i -&gt; j</span></span><br><span class="line">					<span class="keyword">if</span> (mp[k][i] != INF) dp[i][k][step][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][k][step][<span class="number">1</span>], dp[i][j][step<span class="number">-1</span>][<span class="number">0</span>] + mp[k][i]);</span><br><span class="line">					<span class="comment">//k -&gt; j -&gt; i</span></span><br><span class="line">					<span class="keyword">if</span> (mp[k][j] != INF) dp[i][k][step][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][k][step][<span class="number">1</span>], dp[i][j][step<span class="number">-1</span>][<span class="number">1</span>] + mp[k][j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) &#123;<span class="comment">//枚举所有区间</span></span><br><span class="line">			<span class="keyword">int</span> t = <span class="built_in">min</span>(dp[i][j][K][<span class="number">0</span>],dp[i][j][K][<span class="number">1</span>]);<span class="comment">//刚好走了K步</span></span><br><span class="line">			ans = <span class="built_in">min</span>(ans, t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; (ans == <span class="number">1e9</span> ? <span class="number">-1</span> : ans) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h1 id="思路2-记忆化搜索"><a href="#思路2-记忆化搜索" class="headerlink" title="思路2 - 记忆化搜索"></a><strong>思路2 - 记忆化搜索</strong></h1><p>记忆化搜索的话我们就可以正着思考了（比较容易理清），先枚举所有点作为起点起点。若当前走了now这个点，那么下一个点可以是[l+1,now-1]和[now+1,r-1]。l是走过的点中小于now的最大的点，r是走过的点中大于now的最小的点。然后继续搜索，同时更新步数和l，r，当已经K步后返回一个0。</p>
<p>就像上面所说的，我们的每走完一步都会更新边界，也就是now就是其中一个边界，这样我们就可以优化掉其中一个边界。</p>
<ul>
<li>dp[now][go][step]表示当前选了now，下一步另一个边界为go，还需要走step个点</li>
</ul>
<p><strong>代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">102</span>][<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> go, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (~dp[now][go][cnt]) <span class="keyword">return</span>  dp[now][go][cnt];<span class="comment">//记忆化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!cnt) &#123;</span><br><span class="line">		<span class="keyword">return</span> dp[now][go][cnt] = <span class="number">0</span>;<span class="comment">//已经K个点了</span></span><br><span class="line">	&#125;</span><br><span class="line">	dp[now][go][cnt] = <span class="number">1e9</span>;<span class="comment">//初始化为最大值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">min</span>(now,go) + <span class="number">1</span>; i &lt; <span class="built_in">max</span>(now,go); i ++) &#123;<span class="comment">//枚举可以走的点</span></span><br><span class="line">		<span class="keyword">int</span> w = mp[now][i];</span><br><span class="line">		dp[now][go][cnt] = <span class="built_in">min</span>(&#123;dp[now][go][cnt],<span class="built_in">min</span>(<span class="built_in">dfs</span>(i,now,cnt<span class="number">-1</span>),<span class="built_in">dfs</span>(i,go,cnt<span class="number">-1</span>)) + w&#125;);<span class="comment">//继续搜索</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[now][go][cnt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">	<span class="built_in">memset</span>(mp,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(mp));</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; K &gt;&gt; M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b, c;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		mp[a][b] = <span class="built_in">min</span>(mp[a][b], c);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;<span class="comment">//枚举起点</span></span><br><span class="line">		ans = <span class="built_in">min</span>(&#123;ans,<span class="built_in">dfs</span>(i,<span class="number">0</span>,K<span class="number">-1</span>),<span class="built_in">dfs</span>(i,N+<span class="number">1</span>,K<span class="number">-1</span>)&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (ans == <span class="number">1e9</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week1-day3 - daimayuanoj451. Dis</title>
    <url>/2022/02/28/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week1-day3%20-%20daimayuanoj451.%20Dis/</url>
    <content><![CDATA[<p><a href="http://oj.daimayuan.top/submissions">#451. Dis</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a><strong>题意</strong></h1><p>给你一棵树和每个点权值，每次询问你u，v路径上所有点的异或和。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h1><p>模板题<br>树上前缀异或和+lca。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(maxn)</span></span>;</span><br><span class="line"><span class="keyword">int</span> e[maxn],w[maxn],ne[maxn],h[maxn],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[maxn], fa[maxn][<span class="number">20</span>], q[maxn],sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep[<span class="number">0</span>] = <span class="number">0</span>, dep[root] = <span class="number">1</span>; <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">	sum[<span class="number">0</span>] = a[root];</span><br><span class="line">	q[ ++ tt] = root;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[hh ++];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; ~i ; i = ne[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!dep[j])</span><br><span class="line">            &#123;</span><br><span class="line">            	dep[j] = dep[u] + <span class="number">1</span>;</span><br><span class="line">				q[ ++ tt] = j;</span><br><span class="line">				sum[j] = sum[u] ^ a[j];</span><br><span class="line">				fa[j][<span class="number">0</span>] = u;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">19</span>; k ++)</span><br><span class="line">				fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[a] &lt; dep[b]) <span class="built_in">swap</span>(a, b); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">	        <span class="keyword">if</span>(dep[fa[a][i]] &gt;= dep[b])  a = fa[a][i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(a == b)  <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i --) </span><br><span class="line">		<span class="keyword">if</span>(fa[a][i] != fa[b][i]) &#123;</span><br><span class="line">			a = fa[a][i];</span><br><span class="line">            b = fa[b][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(N+<span class="number">10</span>));</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cin &gt;&gt; a[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		<span class="built_in">add</span>(u,v);</span><br><span class="line">		<span class="built_in">add</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		<span class="keyword">int</span> same = <span class="built_in">lca</span>(u, v);</span><br><span class="line">		<span class="keyword">int</span> ans = sum[u] ^ sum[v] ^ a[same];</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week1-day4 - daimayuanoj456. 选数</title>
    <url>/2022/03/01/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week1-day4%20-%20daimayuanoj456.%20%E9%80%89%E6%95%B0/</url>
    <content><![CDATA[<p><a href="http://oj.daimayuan.top/problem/456">选数</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a><strong>题意</strong></h1><p>给你N个数，选出若干个，他们的和模N为0，输出这些数的个数和下标。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h1><ul>
<li>模N最多有N种结果[0,N)，对于这N个数的前缀和sum有N个，再加上全都不选的一个0，就有N+1个数值，则必有两个前缀相等，这两个前缀差分一下，中间那段和模N就是0.</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cin &gt;&gt; a[i], a[i] %= N;</span><br><span class="line">		</span><br><span class="line">	map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	st[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		(sum += a[i]) %= N;</span><br><span class="line">		<span class="keyword">if</span> (st.<span class="built_in">count</span>(sum)) &#123;</span><br><span class="line">			cout &lt;&lt; i-st[sum] &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = st[sum] + <span class="number">1</span>; j &lt;= i; j ++) &#123;</span><br><span class="line">				cout &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		st[sum] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week1-day5 - daimayuanoj452. 序列操作</title>
    <url>/2022/03/02/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week1-day5%20-%20daimayuanoj452.%20%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><a href="http://oj.daimayuan.top/problem/452">序列操作</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a><strong>题意</strong></h1><p>给你一个长度N的序列，有M次操作，操作有两种</p>
<ul>
<li>把一个位置的数改成x</li>
<li>把小于x的数都改成x</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h1><p>注意到第二种操作是非严格单调增的。我们只需要取一个后缀的最大值。<br>当某个位置遇到操作一，则该位置的大小应该固定了，因为它前面的修改对其没有影响。<br>读入很大，cin记得关同步</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-keyword">error</span>(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N)</span>, <span class="title">ans</span><span class="params">(N,<span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) cin &gt;&gt; a[i];</span><br><span class="line">		</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(M)</span>, <span class="title">y</span><span class="params">(M)</span>, <span class="title">z</span><span class="params">(M)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; x[i];</span><br><span class="line">		<span class="keyword">if</span> (x[i] == <span class="number">2</span>) &#123;</span><br><span class="line">			cin &gt;&gt; y[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cin &gt;&gt; y[i] &gt;&gt; z[i];</span><br><span class="line">			y[i] --;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> mmax = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = M - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x[i] == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ans[y[i]] == <span class="number">-1</span>) &#123;</span><br><span class="line">				a[y[i]] = <span class="built_in">max</span>(&#123;z[i], mmax&#125;);</span><br><span class="line">				ans[y[i]] = a[y[i]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mmax = <span class="built_in">max</span>(mmax, y[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		cout &lt;&lt; (ans[i] == <span class="number">-1</span> ? <span class="built_in">max</span>(a[i],mmax) : a[i]) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="线段树-区间修改最大值-单点修改"><a href="#线段树-区间修改最大值-单点修改" class="headerlink" title="线段树 区间修改最大值+单点修改"></a>线段树 区间修改最大值+单点修改</h1><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-keyword">error</span>(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(maxn)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span>&#123;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> ls u &lt;&lt; 1</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> rs u &lt;&lt; 1 | 1</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> l, r, mmax;</span><br><span class="line">		<span class="keyword">int</span> lazy;</span><br><span class="line">	&#125;tr[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		tr[u].mmax = <span class="built_in">max</span>(tr[ls].mmax, tr[rs].mmax);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (tr[u].lazy != <span class="number">-1</span>) &#123;</span><br><span class="line">			tr[ls].mmax = <span class="built_in">max</span>(tr[ls].mmax, tr[u].lazy);</span><br><span class="line">			tr[rs].mmax = <span class="built_in">max</span>(tr[rs].mmax, tr[u].lazy);</span><br><span class="line">			<span class="keyword">int</span> &amp;la = tr[u].lazy;</span><br><span class="line">			tr[ls].lazy = <span class="built_in">max</span>(tr[ls].lazy, la);</span><br><span class="line">			tr[rs].lazy = <span class="built_in">max</span>(tr[rs].lazy, la);</span><br><span class="line">			la = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		tr[u].l = l, tr[u].r = r;</span><br><span class="line">		<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">			tr[u] = &#123;l,r,a[l], <span class="number">-1</span>&#125;;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">build</span>(ls,l,mid);</span><br><span class="line">		<span class="built_in">build</span>(rs,mid + <span class="number">1</span>, r);</span><br><span class="line">		<span class="built_in">pushup</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;=  r) &#123;</span><br><span class="line">			tr[u].mmax = <span class="built_in">max</span>(tr[u].mmax, x);</span><br><span class="line">			tr[u].lazy = <span class="built_in">max</span>(tr[u].lazy, x);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="keyword">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (mid &gt;= l) &#123;</span><br><span class="line">			<span class="built_in">update</span>(ls,l,r,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (r &gt; mid) &#123;</span><br><span class="line">			<span class="built_in">update</span>(rs,l,r,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pushup</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">modify</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (tr[u].l == tr[u].r) &#123;</span><br><span class="line">			tr[u].lazy = <span class="number">-1</span>;</span><br><span class="line">			tr[u].mmax = x;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="keyword">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (p &lt;= mid) <span class="built_in">modify</span>(ls,p,x);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">modify</span>(rs,p,x);</span><br><span class="line">		<span class="built_in">pushup</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (tr[u].l == tr[u].r &amp;&amp; tr[u].l == p) &#123;</span><br><span class="line">			<span class="keyword">return</span> tr[u].mmax;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="keyword">int</span> mid = (tr[u].l + tr[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (p &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(ls,p);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rs,p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cin &gt;&gt; a[i];</span><br><span class="line">	tr.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,N);</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(M)</span>, <span class="title">y</span><span class="params">(M)</span>, <span class="title">z</span><span class="params">(M)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; x[i];</span><br><span class="line">		<span class="keyword">if</span> (x[i] == <span class="number">2</span>) &#123;</span><br><span class="line">			cin &gt;&gt; y[i];</span><br><span class="line">			tr.<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,N,y[i]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cin &gt;&gt; y[i] &gt;&gt; z[i];</span><br><span class="line">			tr.<span class="built_in">modify</span>(<span class="number">1</span>,y[i],z[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		cout &lt;&lt; tr.<span class="built_in">query</span>(<span class="number">1</span>,i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);	</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week1-day6 - daimayuanoj464. 数数</title>
    <url>/2022/03/03/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week1-day6%20-%20daimayuanoj464.%20%E6%95%B0%E6%95%B0/</url>
    <content><![CDATA[<h1 id="数数"><a href="#数数" class="headerlink" title="数数"></a><a href="http://oj.daimayuan.top/problem/464">数数</a></h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>在给定 𝑁 长的数组 {𝐴} 中进行 𝑄 次询问 [𝐿𝑖,𝑅𝑖] 区间中不大于 𝐻𝑖 的元素个数。</p>
<p>共包含 𝑇 组数据。</p>
<h1 id="1-莫队-树状数组（3e8没被卡）"><a href="#1-莫队-树状数组（3e8没被卡）" class="headerlink" title="1.莫队 + 树状数组（3e8没被卡）"></a>1.莫队 + 树状数组（3e8没被卡）</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>离散化所有a和查询的h</li>
<li>树状数组维护当前区间各种取值的个数</li>
<li>莫队修改区间</li>
<li>复杂度O(N<em>sqrt(N)</em>log(N))</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-keyword">error</span>(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"><span class="keyword">int</span> blo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, h, id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> id[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (id[a.l] != id[b.l]) <span class="keyword">return</span> id[a.l] &lt; id[b.l];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fenwick</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="keyword">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">a</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n<span class="number">-1</span>; i += i &amp; -i) &#123;</span><br><span class="line">            a[i] += v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= i &amp; -i) &#123;</span><br><span class="line">            ans += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; Q;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">	vector&lt;node&gt; query;</span><br><span class="line">	blo = (ll)<span class="built_in">sqrt</span>((<span class="keyword">double</span>)N);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		v.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r, h;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r &gt;&gt; h;</span><br><span class="line">		id[l] = l / blo;</span><br><span class="line">		id[r] = r / blo;</span><br><span class="line">		v.<span class="built_in">push_back</span>(h);</span><br><span class="line">		query.<span class="built_in">push_back</span>(&#123;l, r, h, i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">	v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()),v.<span class="built_in">end</span>());</span><br><span class="line">	</span><br><span class="line">	M = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		a[i] = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),a[i]) - v.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		query[i].h = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),query[i].h) - v.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(query.<span class="built_in">begin</span>(),query.<span class="built_in">end</span>(),cmp);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function">Fenwick&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(M+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> move = [&amp;](<span class="keyword">int</span> p) &#123;</span><br><span class="line">		<span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (p &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">			p = - p;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		t.<span class="built_in">add</span>(p,f);</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(Q+<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> l = query[<span class="number">0</span>].l, r = query[<span class="number">0</span>].r;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line">		ans[query[<span class="number">0</span>].id] += a[i] &lt;= query[<span class="number">0</span>].h;</span><br><span class="line">		t.<span class="built_in">add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		<span class="keyword">auto</span> &amp;q = query[i];</span><br><span class="line">	    <span class="keyword">while</span> (l &gt; q.l) <span class="built_in">move</span>(a[--l]);</span><br><span class="line">	    <span class="keyword">while</span> (r &lt; q.r) <span class="built_in">move</span>(a[++r]);</span><br><span class="line">	    <span class="keyword">while</span> (l &lt; q.l) <span class="built_in">move</span>(-a[l++]);</span><br><span class="line">	    <span class="keyword">while</span> (r &gt; q.r) <span class="built_in">move</span>(-a[r--]);</span><br><span class="line">	    ans[q.id] = t.<span class="built_in">sum</span>(q.h);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="2-莫队-分块（2Nsqrt-N-）"><a href="#2-莫队-分块（2Nsqrt-N-）" class="headerlink" title="2.莫队+分块（2Nsqrt(N)）"></a>2.莫队+分块（2<em>N</em>sqrt(N)）</h1><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li>和第一个做法差不多，不过莫队主要复杂度在于n*sqrt(n)次修改，树状数组的修改是log，分块修改是O(1)，查询是O(sqrt(n));</li>
<li>所以复杂度是O(2 <em> N</em>sqrt(N)）</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-keyword">error</span>(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"><span class="keyword">int</span> blo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, h, id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> id[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (id[a.l] != id[b.l]) <span class="keyword">return</span> id[a.l] &lt; id[b.l];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; Q;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">	vector&lt;node&gt; query;</span><br><span class="line">	blo = (ll)<span class="built_in">sqrt</span>((<span class="keyword">double</span>)N);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		v.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r, h;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r &gt;&gt; h;</span><br><span class="line">		id[l] = l / blo;</span><br><span class="line">		id[r] = r / blo;</span><br><span class="line">		v.<span class="built_in">push_back</span>(h);</span><br><span class="line">		query.<span class="built_in">push_back</span>(&#123;l, r, h, i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">	v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()),v.<span class="built_in">end</span>());</span><br><span class="line">	</span><br><span class="line">	M = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		a[i] = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),a[i]) - v.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		query[i].h = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),query[i].h) - v.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(query.<span class="built_in">begin</span>(),query.<span class="built_in">end</span>(),cmp);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> block = <span class="built_in">sqrt</span>(M);</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">idv</span><span class="params">(M+<span class="number">1</span>)</span>,<span class="title">sum</span><span class="params">(block + <span class="number">10</span>)</span>,<span class="title">vv</span><span class="params">(M+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M + <span class="number">1</span>; i ++) idv[i] = i / block;</span><br><span class="line">	<span class="keyword">auto</span> add = [&amp;](<span class="keyword">int</span> p) &#123;</span><br><span class="line">		<span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (p &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			f = <span class="number">-1</span>;</span><br><span class="line">			p = - p;</span><br><span class="line">		&#125;</span><br><span class="line">		vv[p] += f;</span><br><span class="line">		sum[idv[p]] += f;</span><br><span class="line">		</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> ask = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="keyword">int</span> idr = idv[x];</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idr; i ++) &#123;</span><br><span class="line">			ans += sum[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = idr * block; i &lt;= x; i ++) &#123;</span><br><span class="line">			ans += vv[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(Q+<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> l = query[<span class="number">0</span>].l, r = query[<span class="number">0</span>].r;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++) &#123;</span><br><span class="line">		ans[query[<span class="number">0</span>].id] += a[i] &lt;= query[<span class="number">0</span>].h;</span><br><span class="line">		<span class="built_in">add</span>(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		<span class="keyword">auto</span> &amp;q = query[i];</span><br><span class="line">	    <span class="keyword">while</span> (l &gt; q.l) <span class="built_in">add</span>(a[--l]);</span><br><span class="line">	    <span class="keyword">while</span> (r &lt; q.r) <span class="built_in">add</span>(a[++r]);</span><br><span class="line">	    <span class="keyword">while</span> (l &lt; q.l) <span class="built_in">add</span>(-a[l++]);</span><br><span class="line">	    <span class="keyword">while</span> (r &gt; q.r) <span class="built_in">add</span>(-a[r--]);</span><br><span class="line">	    ans[q.id] = <span class="built_in">ask</span>(q.h);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>对于所有询问按照h排序，每次把小于等于h的a[i]的位置插入到树状数组，这样答案就是区间[l,r]的和。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-keyword">error</span>(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qq</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, h, id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(qq a, qq b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.h &lt; b.h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fenwick</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="keyword">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">a</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += i &amp; -i) &#123;</span><br><span class="line">            a[i] += v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= i &amp; -i) &#123;</span><br><span class="line">            ans += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; Q;</span><br><span class="line">	vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; <span class="built_in">a</span>(N+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i].first;</span><br><span class="line">		a[i].first = -a[i].first;</span><br><span class="line">		a[i].second = i;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		q.<span class="built_in">push</span>(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;qq&gt; <span class="title">query</span><span class="params">(Q)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r, h;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r &gt;&gt; h;</span><br><span class="line">		query[i] = &#123;l, r, h, i&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(query.<span class="built_in">begin</span>(),query.<span class="built_in">end</span>(),cmp);</span><br><span class="line">	</span><br><span class="line">	<span class="function">Fenwick&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">100010</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(Q)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		<span class="comment">// error(q.top().first);</span></span><br><span class="line">		<span class="keyword">auto</span> [l,r,h,id] = query[i];</span><br><span class="line">		<span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; -q.<span class="built_in">top</span>().first &lt;= h) &#123;</span><br><span class="line">			<span class="keyword">auto</span> [hh,p] = q.<span class="built_in">top</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			t.<span class="built_in">add</span>(p,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ans[id] = t.<span class="built_in">rangeSum</span>(l,r);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="主席树在线做法"><a href="#主席树在线做法" class="headerlink" title="主席树在线做法"></a>主席树在线做法</h1><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>主席树的版本就是查询的区间，维护的值是a[i]的个数。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-keyword">error</span>(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, cnt;</span><br><span class="line">&#125;tr[maxn * <span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root[maxn], tot;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(maxn)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = ++ tot;</span><br><span class="line">	tr[t] = tr[u];</span><br><span class="line">	tr[t].cnt ++;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> t;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">		tr[t].l = <span class="built_in">insert</span>(tr[u].l, l, mid, x);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tr[t].r = <span class="built_in">insert</span>(tr[u].r,mid + <span class="number">1</span>, r, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> tr[p].cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; mid) &#123;</span><br><span class="line">		<span class="keyword">return</span> tr[tr[p].l].cnt + <span class="built_in">ask</span>(tr[p].r, mid + <span class="number">1</span>, r, x);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ask</span>(tr[p].l, l, mid, x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; Q;</span><br><span class="line">	a.<span class="built_in">resize</span>(N+<span class="number">1</span>);</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		v.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">	v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()),v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> len = v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// cout &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> find = [&amp;](<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),x) - v.<span class="built_in">begin</span>();</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>], <span class="number">1</span>, len, <span class="built_in">find</span>(a[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r, h;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r &gt;&gt; h;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">ask</span>(root[r],<span class="number">1</span>,len,<span class="built_in">find</span>(h)) - <span class="built_in">ask</span>(root[l<span class="number">-1</span>],<span class="number">1</span>,len,<span class="built_in">find</span>(h)) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week1-day7 - daimayuanoj454. Minimum Or Spanning Tree</title>
    <url>/2022/03/04/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week1-day7%20-%20daimayuanoj454.%20Minimum%20Or%20Spanning%20Tree/</url>
    <content><![CDATA[<p><a href="http://oj.daimayuan.top/course/10/problem/454">Minimum Or Spanning Tree</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>求图的最小或生成树，权值是所有边权或起来的值</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>答案的每一位可以分开考虑</li>
<li>因为是或，答案这一位要想是0，则要求所选的边这一位上都是0，我们把边权符合的边都选上，看是否能够将所有点联通</li>
<li>我们从高到低考虑每一位，枚举当前位时，这条边还要满足前面位的要求</li>
<li>当答案这一位是0，则后面所选边的这一位必须是0，如果是1，则没有要求。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-keyword">error</span>(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line">vector&lt;array&lt;<span class="keyword">int</span>,3&gt; &gt; edges;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DSU</span> &#123;</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; f, siz;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="keyword">int</span> n) : <span class="built_in">f</span>(n), <span class="built_in">siz</span>(n, <span class="number">1</span>) &#123; std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leader</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) x = f[x] = f[f[x]];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leader</span>(x) == <span class="built_in">leader</span>(y); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">leader</span>(x);</span><br><span class="line">        y = <span class="built_in">leader</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> siz[<span class="built_in">leader</span>(x)]; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	edges.<span class="built_in">clear</span>();</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, w;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		u--,v--;</span><br><span class="line">		edges.<span class="built_in">push_back</span>(&#123;u,v,w&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">//逆向思维，最后减去</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">		<span class="keyword">int</span> cur = ans + (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">		<span class="function">DSU <span class="title">g</span><span class="params">(N)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> [u,v,w] : edges) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((w &amp; cur) == <span class="number">0</span>) &#123;<span class="comment">//ans是1的位，必须是0</span></span><br><span class="line">				g.<span class="built_in">merge</span>(u,v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> f = <span class="number">1</span>;<span class="comment">//判断是否联通</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) </span><br><span class="line">			<span class="keyword">if</span> (!g.<span class="built_in">same</span>(<span class="number">0</span>,i)) f = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (f) ans = cur;<span class="comment">//更新答案</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; (<span class="number">1</span>&lt;&lt;<span class="number">30</span>)<span class="number">-1</span>-ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week2-day3 - daimayuanoj468. 函数求和</title>
    <url>/2022/03/07/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week2-day3%20-%20daimayuanoj468.%20%E5%87%BD%E6%95%B0%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h1 id="函数求和"><a href="#函数求和" class="headerlink" title="函数求和"></a><a href="http://oj.daimayuan.top/problem/468">函数求和</a></h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>直接看题目吧（不想敲公式.jpg）</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>从小到大枚举a[i]，计算有多少个数&amp;a[i]不等于a[i]，就是a[i]等于1的位上至少有一个是0，等于0的位上随便取，所以答案是power(2,cnt0)*(power(2,cnt1)-1)</p>
<p>但是当前枚举的数可能再更小i的a[i]被枚举，所以我们枚举的数还得满足&amp;a[j]（j &lt; i）等于a[j]的条件，就是a[j]等于1的位上一定是1，等于0的位上随便取。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">norm</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x += P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= P) &#123;</span><br><span class="line">        x -= P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">power</span><span class="params">(T a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    T res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Z</span> &#123;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">Z</span>(<span class="keyword">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    Z <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="built_in">norm</span>(P - x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">inv</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, P - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">i64</span>(x) * rhs.x % P;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>/=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>*(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>+(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>-(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>/(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Z ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> limit = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//limit 1的地方必须是0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//&amp;相同，一是一</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> sum = K;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j ++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((limit &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				sum --;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				cnt += ((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Z temp = <span class="built_in">power</span>((Z)<span class="number">2</span>,cnt)*(<span class="built_in">power</span>((Z)<span class="number">2</span>,sum-cnt)<span class="number">-1</span>);</span><br><span class="line">		ans += temp * <span class="built_in">Z</span>(i + <span class="number">1</span>);</span><br><span class="line">		limit |= a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; ans.<span class="built_in">val</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week2-day1 - daimayuanoj466. 摘桃子</title>
    <url>/2022/03/05/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week2-day1%20-%20daimayuanoj466.%20%E6%91%98%E6%A1%83%E5%AD%90/</url>
    <content><![CDATA[<h1 id="摘桃子"><a href="#摘桃子" class="headerlink" title="摘桃子"></a><a href="http://oj.daimayuan.top/course/10/problem/466">摘桃子</a></h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有多少个字串（连续的）满足所有元素和模K等于字串的长度</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>长度是和模K相同，那么长度不超过K，我们可以用滑动窗口</li>
<li>模K等于字串的长度，令a[i] = a[i] - 1，那么就是字串和模长度等于0</li>
<li>求有多少个区间和是K的倍数，我们把a[i]=%K然后再DP一下，K可能很大，要用map</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N+<span class="number">1</span>)</span>, <span class="title">sum</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		sum[i] = (sum[i<span class="number">-1</span>] + a[i] - <span class="number">1</span>) % K;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">	</span><br><span class="line">	cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i &gt;= K) cnt[sum[i - K]] --;<span class="comment">//长度大于等于K了，左端点右滑</span></span><br><span class="line">		ans += cnt[sum[i]];</span><br><span class="line">		cnt[sum[i]] ++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week2-day2 - daimayuanoj467. 路径计数2</title>
    <url>/2022/03/06/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week2-day2%20-%20daimayuanoj467.%20%E8%B7%AF%E5%BE%84%E8%AE%A1%E6%95%B02/</url>
    <content><![CDATA[<h1 id="路径计数2"><a href="#路径计数2" class="headerlink" title="路径计数2"></a><a href="http://oj.daimayuan.top/problem/467">路径计数2</a></h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个N*N的网格，再给你M个障碍物的坐标，问你从（1，1）点走到（M，M）点有多少种方法。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>N的大小右1e6，肯定不能正常DP，注意M的范围是3000，可以想到应该是一个M方的算法。</p>
<p>我们定义dp[i]是从（1，1）走到第i个点之前没碰到障碍物后面随便走，那么我们算dp[i]的转移应该为没有限制下（1，1）走到第i个点再减去dp<a href="j&lt;i">j</a>,按照第一个走到的障碍物是哪个枚举了所有不合法情况。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">    cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">norm</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x += P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= P) &#123;</span><br><span class="line">        x -= P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">power</span><span class="params">(T a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    T res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Z</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">Z</span>(<span class="keyword">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    Z <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="built_in">norm</span>(P - x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">inv</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, P - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">i64</span>(x) * rhs.x % P;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>/=(<span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>*(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>+(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>-(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>/(<span class="keyword">const</span> Z &amp;lhs, <span class="keyword">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    </span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; <span class="built_in">a</span>(M);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x,y] : a) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    a.<span class="built_in">push_back</span>(&#123;N,N&#125;);</span><br><span class="line">    <span class="function">vector&lt;Z&gt; <span class="title">dp</span><span class="params">(M+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;Z&gt; <span class="title">fact</span><span class="params">(<span class="number">2</span>*N+<span class="number">1</span>)</span>, <span class="title">infact</span><span class="params">(<span class="number">2</span>*N+<span class="number">1</span>)</span></span>;</span><br><span class="line">    fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>*N; i ++) fact[i] = i * fact[i<span class="number">-1</span>];</span><br><span class="line">  </span><br><span class="line">    infact[<span class="number">2</span>*N] = fact[<span class="number">2</span>*N].<span class="built_in">inv</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>*N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) infact[i] = infact[i+<span class="number">1</span>] * (i+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> combine = [&amp;](<span class="keyword">int</span> n, <span class="keyword">int</span> m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m || n &lt; <span class="number">0</span> || m &lt; <span class="number">0</span>) <span class="built_in"><span class="keyword">return</span></span> (Z)<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> infact[m] * infact[n-m] * fact[n];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i ++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">combine</span>(a[i].first + a[i].second - <span class="number">2</span>, a[i].first - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> [x,y] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [xx,yy] = a[j];</span><br><span class="line">            <span class="keyword">if</span> (xx &gt; x || yy &gt; y) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] -= dp[j]*<span class="built_in">combine</span>(x + y - xx - yy, x - xx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dp[M].<span class="built_in">val</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week2-day4 - daimayuanoj497. XOR Inverse</title>
    <url>/2022/03/08/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week2-day4%20-%20daimayuanoj497.%20XOR%20Inverse/</url>
    <content><![CDATA[<h1 id="XOR-Inverse"><a href="#XOR-Inverse" class="headerlink" title="XOR Inverse"></a><a href="http://oj.daimayuan.top/problem/497">XOR Inverse</a></h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你N个数，给每个数都异或上x，求使新得到的数组的逆序对最少的x，和逆序对数量，如果有多个逆序对相同的x，求最小的x。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>从高到低对于每一位考虑，然后将所有数按照这一位是0还是1分组，继续递归下去。因为不同组之间这一位一定不同，也就是说大小关系已经确认了，所以后面的变化不会影响不同组之间的逆序对数量，所以我们只需要递归考虑每一组内部的逆序对即可。</p>
<p>最后只有比较一下x这一位放1还是0哪个逆序对数量少，如果相同放0（保证x最小）</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">    cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp1</span><span class="params">(<span class="keyword">int</span> wei, vector&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wei &lt; <span class="number">0</span> || a.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> o = <span class="number">0</span>,z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ni = <span class="number">0</span>, ni2 = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((a[i] &gt;&gt; wei) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            o ++;</span><br><span class="line">            x.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            ni2 += z;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ni += o;</span><br><span class="line">            z ++;</span><br><span class="line">            y.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[wei][<span class="number">0</span>] += ni;</span><br><span class="line">    dp[wei][<span class="number">1</span>] += ni2;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dp1</span>(wei<span class="number">-1</span>,x);</span><br><span class="line">    <span class="built_in">dp1</span>(wei<span class="number">-1</span>,y);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) cin &gt;&gt; a[i];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">dp1</span>(<span class="number">31</span>,a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][<span class="number">0</span>] &lt;= dp[i][<span class="number">1</span>]) &#123;</span><br><span class="line">            ans += dp[i][<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += dp[i][<span class="number">1</span>];</span><br><span class="line">            res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0 1 3 2</span></span><br><span class="line">    <span class="comment">// 0 0 1 1</span></span><br><span class="line">    <span class="comment">// 0 1 1 0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week2-day5 - daimayuanoj469. Closest Equals</title>
    <url>/2022/03/09/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week2-day5%20-%20daimayuanoj469.%20Closest%20Equals/</url>
    <content><![CDATA[<h1 id="Closest-Equals"><a href="#Closest-Equals" class="headerlink" title="Closest Equals"></a><a href="http://oj.daimayuan.top/course/10/problem/469">Closest Equals</a></h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>问你区间内任意两个相同的数的最小距离</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对于每个点和他前一个相同的点可以看成一个线段的两个端点，这样问题转化为了求完全包含于询问区间内的最短线段。</p>
<p>如果一条线段i包含于另一条线段j，那么线段j可以删去。因为线段j在区间内，则线段i一定也在区间内，而线段i更短。</p>
<p>我们枚举的i是右端点，是递增的，满足两个线段没有包含关系，则左端点也是递增的。</p>
<p>由此我们可以二分出一段区间，这些线段是在询问区间内的，我们只需要用rmq查询区间最小值。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); cout &lt;&lt; endl;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">    cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l[maxn], r[maxn], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RMQ</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highest_bit</span><span class="params">(<span class="keyword">unsigned</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">31</span> - __builtin_clz(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;T&gt;&gt; range_min;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">RMQ</span>(<span class="keyword">const</span> vector&lt;T&gt; &amp;values = &#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!values.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">build</span>(values);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">better</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> vector&lt;T&gt; &amp;values)</span> </span>&#123;</span><br><span class="line">        n = (<span class="keyword">int</span>)(values.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">int</span> levels = <span class="built_in">highest_bit</span>(n) + <span class="number">1</span>;</span><br><span class="line">        range_min.<span class="built_in">resize</span>(levels);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; levels; k++)</span><br><span class="line">            range_min[k].<span class="built_in">resize</span>(n - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            range_min[<span class="number">0</span>] = values;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; levels; k++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; k); i++)</span><br><span class="line">                range_min[k][i] = <span class="built_in">better</span>(range_min[k - <span class="number">1</span>][i], range_min[k - <span class="number">1</span>][i + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">T <span class="title">query_value</span><span class="params">(ll a, ll b)</span> <span class="keyword">const</span> </span>&#123;<span class="comment">//[a,b),idx from 1</span></span><br><span class="line">        <span class="comment">// assert(0 &lt;= a &amp;&amp; a &lt; b &amp;&amp; b &lt;= n);</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="built_in">highest_bit</span>(b - a + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">better</span>(range_min[level][a], range_min[level][b - (<span class="number">1</span> &lt;&lt; level) + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; las;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">int</span> pre = las[x];</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="number">0</span>) &#123;</span><br><span class="line">            las[x] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre &gt; l[tot]) &#123;</span><br><span class="line">                l[++tot] = pre;</span><br><span class="line">                r[tot] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            las[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(tot)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i ++) &#123;</span><br><span class="line">        <span class="comment">// debug(i, l[i], r[i]);</span></span><br><span class="line">        a[i - <span class="number">1</span>] = r[i] - l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RMQ&lt;<span class="keyword">int</span>&gt; <span class="title">rmq</span><span class="params">(a)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line">        <span class="keyword">int</span> LL = <span class="built_in">lower_bound</span>(l + <span class="number">1</span>, l + <span class="number">1</span> + tot, L) - l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> RR = <span class="built_in">upper_bound</span>(r + <span class="number">1</span>, r + <span class="number">1</span> + tot, R) - r - <span class="number">1</span>;</span><br><span class="line">        RR --;</span><br><span class="line">        <span class="comment">// debug(LL, RR);</span></span><br><span class="line">        <span class="keyword">if</span> (RR &lt; LL) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; rmq.<span class="built_in">query_value</span>(LL,RR) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week2-day6 - daimayuanoj380.Damaged Bicycle</title>
    <url>/2022/03/10/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week2-day6%20-%20daimayuanoj380.Damaged%20Bicycle/</url>
    <content><![CDATA[<h1 id="Damaged-Bicycle"><a href="#Damaged-Bicycle" class="headerlink" title="Damaged Bicycle"></a><a href="http://oj.daimayuan.top/course/10/problem/380">Damaged Bicycle</a></h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一张N个点，M条边的图，其中K个点有共享单车，每辆单车有p[i]的概率是坏的。走路的速度是t，骑车的速度是r。问你从1号点走到N号点的最小期望时间是多少。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul>
<li>生活常识，骑车的速度比走路快，所以为了时间最小，一旦我们成功骑到车我们将沿着最短路走到终点。而在此之前我们都是走路。</li>
<li>走的路全部都是最短路，所以我们要预处理起点，终点，有车点到其他点的最短路。</li>
<li>用dp[S][i]状压代表S二进制中1的单车都坏了的情况下当前在i到终点还需要的时间的最小期望。</li>
<li>转移方程<ol>
<li>车是好的，直接骑到终点。t_car</li>
<li>车是坏的<ul>
<li>走到还没确认好坏的车那里</li>
<li>走路到终点</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>答案是1+min（2）</p>
<ul>
<li>dp[s][i] = dp[s | (1 &lt;&lt; j)][j] + d[i][j] / v_walk;</li>
<li>最后枚举在哪个点扫到车就好了，时间是d[k][i] / t_walk + dp[1&lt;&lt;i][i];</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">	cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">5e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e[maxm],w[maxm],ne[maxm],h[maxn],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(maxn+<span class="number">7</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	dis[u] = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; , vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;&gt; heap;</span><br><span class="line">	heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, u&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dis[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">20</span>][<span class="number">18</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(maxn));</span><br><span class="line">	<span class="keyword">int</span> t, r;</span><br><span class="line">	cin &gt;&gt; t &gt;&gt; r;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i ++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v, w;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		<span class="built_in">add</span>(u, v, w);</span><br><span class="line">		<span class="built_in">add</span>(v, u, w);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; K;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(K + <span class="number">2</span>)</span>, <span class="title">p</span><span class="params">(K)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i ++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i] &gt;&gt; p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a[K] = <span class="number">1</span>;</span><br><span class="line">	a[K + <span class="number">1</span>] = N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K + <span class="number">2</span>; i ++) &#123;</span><br><span class="line">		<span class="built_in">dijkstra</span>(a[i]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K + <span class="number">2</span>; j ++) &#123;</span><br><span class="line">			d[i][j] = dis[a[j]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (d[K][K + <span class="number">1</span>] == INF) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> S = (<span class="number">1</span> &lt;&lt; K) - <span class="number">1</span>; S &gt;= <span class="number">0</span>; S --) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i ++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((S &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">double</span> pbad = <span class="number">0.01</span> * p[i];</span><br><span class="line">				<span class="keyword">double</span> t_car = <span class="number">1.</span> * d[i][K + <span class="number">1</span>] / r;<span class="comment">//开车到终点</span></span><br><span class="line">				<span class="keyword">double</span> t_walk = <span class="number">1.</span> * d[i][K + <span class="number">1</span>] / t;<span class="comment">//走路到终点</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j ++) &#123;</span><br><span class="line">					<span class="keyword">if</span> ((S &gt;&gt; j) &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">					t_walk = <span class="built_in">min</span>(t_walk, <span class="number">1.</span> * d[i][j] / t + dp[S | (<span class="number">1</span> &lt;&lt; j)][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				dp[S][i] = pbad * t_walk + (<span class="number">1</span> - pbad) * t_car;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> ans = <span class="number">1.</span> * d[K][K + <span class="number">1</span>] / t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i ++) &#123;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, <span class="number">1.</span> * d[K][i] / t + dp[<span class="number">1</span> &lt;&lt; i][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.7lf&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>namomo每日一题week3-day4 - daimayuanoj555. 整齐的数组2</title>
    <url>/2022/03/15/namomo%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week3-day4%20-%20daimayuanoj555.%20%E6%95%B4%E9%BD%90%E7%9A%84%E6%95%B0%E7%BB%842/</url>
    <content><![CDATA[<h1 id="整齐的数组"><a href="#整齐的数组" class="headerlink" title="整齐的数组"></a><a href="http://oj.daimayuan.top/course/10/problem/555">整齐的数组</a></h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>选择一个k，可以对任意数执行若干次，最后能够让数组至少一半相同。问满足条件的最大的k，如果k可以任意打，输出-1。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先，如果开始数组有一半相同，那么直接输出-1.</p>
<p>否则，枚举最后相同的数是a[i]，其他数都和a[i]作差，得到b数组，当k是b[j]的因子，则a[j]可以通过若干次操作变成a[i]。所以我们要根号枚举b[j]<br>。并用map记录次数，如果大于一半则更新答案。</p>
<ul>
<li>枚举因子时，如果b[j]是一个完全平方数，那么只能加一次</li>
<li>如果b[j]和a[i]相等不会被根号枚举，但是可以操作0次和a[i]相等，可以在处理b数组时统计。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); cout &lt;&lt; <span class="meta-string">&quot;\n&quot;</span>;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">  cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">  <span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rd</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   t = s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rd</span><span class="params">(T&amp; t, Args&amp;... args)</span></span>&#123;<span class="built_in">rd</span>(t);<span class="built_in">rd</span>(args...);&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N)</span></span>;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cc;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="comment">// debug(a[i]%13);</span></span><br><span class="line">        cc[a[i]] ++;</span><br><span class="line">        <span class="keyword">if</span> (cc[a[i]] &gt;= N / <span class="number">2</span>) &#123;</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">        <span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">            b.<span class="built_in">push_back</span>(a[i] - a[j]);</span><br><span class="line">            z += (a[i] - a[j] == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j ++) &#123;</span><br><span class="line">            b.<span class="built_in">push_back</span>(a[j] - a[i]);</span><br><span class="line">            z += (a[i] - a[j] == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line">        cc.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); j ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="built_in">sqrt</span>(b[j]); k ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b[j] % k == <span class="number">0</span>) &#123;</span><br><span class="line">                    cc[k] ++;</span><br><span class="line">                    <span class="keyword">if</span> (cc[k] + <span class="number">1</span> + z &gt;= N / <span class="number">2</span>) &#123;</span><br><span class="line">                        ans = <span class="built_in">max</span>(ans, k);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (k*k != b[j]) &#123;</span><br><span class="line">                        cc[b[j] / k] ++;</span><br><span class="line">                        <span class="keyword">if</span> (cc[b[j] / k] + <span class="number">1</span> + z &gt;= N / <span class="number">2</span>) &#123;</span><br><span class="line">                            ans = <span class="built_in">max</span>(ans, b[j]/k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>三角果计数</title>
    <url>/2022/01/18/%E4%B8%89%E8%A7%92%E6%9E%9C%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p><a href="http://oj.daimayuan.top/problem/505">三角果计数</a></p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>求一个数上有几种三点的集合，他们两两的最短路能形成一个三角形。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我们枚举两个点，看有多少个第三点满足条件。</p>
<p>当三个点在同一条链上时，他们的最短路始终满足较小两边加起来等于第三边，不满足三角形。</p>
<p>我们枚举的是其中两个点的最近公共祖先，然后在他的两个子树中各选一个作为其中两个点，那么第三点的数量就是除了这两棵子树和这个点以外的所有点。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), <span class="meta-string">&#x27;,&#x27;</span>, <span class="meta-string">&#x27; &#x27;</span>); stringstream _ss(_s); istream_iterator<span class="meta-string">&lt;string&gt;</span> _it(_ss); err(_it, args); cout &lt;&lt; <span class="meta-string">&quot;\n&quot;</span>;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err</span><span class="params">(istream_iterator&lt;string&gt; it, T a, Args... args)</span> </span>&#123;</span><br><span class="line">  cerr &lt;&lt; *it &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">  <span class="built_in">err</span>(++it, args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e[maxn],w[maxn],ne[maxn],h[maxn],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> siz[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// siz[u] = 1;</span></span><br><span class="line">    <span class="comment">// int x = 1;</span></span><br><span class="line">    <span class="comment">// int f = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(j, u);</span><br><span class="line">        <span class="comment">// x *= siz[j];</span></span><br><span class="line">        ans += siz[j] * siz[u] * (N - siz[u] - siz[j] - <span class="number">1</span>);</span><br><span class="line">        siz[u] += siz[j];</span><br><span class="line">    &#125;</span><br><span class="line">    siz[u] ++;</span><br><span class="line">    <span class="comment">// debug(u, ans, siz[u]);</span></span><br><span class="line">    <span class="comment">// if (f) ans += x * (N - siz[u]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*(maxn));</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// a + b, a + c, b + c;</span></span><br><span class="line"><span class="comment">// a - b, a + c, b + c;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>基尔霍夫矩阵</title>
    <url>/2022/02/21/%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>Matrix-Tree 定理又称基尔霍夫矩阵树定理，其用于解决：给定 n 个点 m 条边的无向图，求图的生成树个数的问题。</p>
<p>【基尔霍夫矩阵】</p>
<h1 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1.基本定义"></a>1.基本定义</h1><p>1）无向图 𝐺：给定 𝑛 个点，𝑚 条边的无向图，设点集为 𝑉，边集为 𝐸，则其记为 𝐺(𝑉,𝐸)<br>2）度数矩阵 𝐷[𝐺]：当 𝑖≠𝑗 时，𝐷[𝑖][𝑗]=0，当 𝑖=𝑗 时，𝐷[𝑖][𝑗]=点𝑣的度数<br>3）邻接矩阵 𝐴[𝐺]：当 𝑣𝑖、𝑣𝑗 有边连接时，𝐴[𝑖][𝑗]=1，当 𝑣𝑖、𝑣𝑗 无边连接时，𝐴[𝑖][𝑗]=0<br>4）基尔霍夫矩阵(Kirchhoff) 𝐾[𝐺]：也称拉普拉斯算子，其定义为 𝐾[𝐺]=𝐷[𝐺]−𝐴[𝐺]，即：𝐾[𝑖][𝑗]=𝐷[𝑖][𝑗]−𝐴[𝑖][𝑗]<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATsAAACgCAMAAABE1DvBAAABmFBMVEX///8AAACTk5P6+vqqqqo0NDR5eXnV1dVbW1vAwMDl5eW2trb39/d/f3+kpKRISEhmZmbLy8vx8fHb29uxsbE3Nzeampo/Pz/0///j4+OGhoZubm7r6+va6/69vb1gYGD///jk2LZ7XEogICAtLS22kofa+fxPT09mh6b///Dt///86tv+8eaHnaWLf3eWf3cTExMcHBz//+WCjo6LprLM7fO+1escMEvj0LTFurHs+P/538qQssP/8diuiX/u49q5xNHJtbWljIKAi6CjmYbTr5Z/jZasjnqMhY24qaTEopTbzsNLMypKRUxvX1B4lKlvSzVBIBiBYUO8nn6du9xLNDR3UzKmxtqFqc4AADN2SRokQ2W0t8I2GSFZQB+kmX+siF86AACVb0gAABhOcZeZe14lHzYsHhAyQU5hbolTYHMiCyLlxqlFXHtgQzU2P2QtAABBWH9nY02Bmr1WbXCIdHiJc2RXeYtzd4SHYDHDsJQALVnz0ba9qY0vS2WkvMdxUVF9gqHG4P+Pe2ikqr1RKQClpZeCfpOzQaRQAAAQ6klEQVR4nO2djV/bxhnH7yz5Dcs2fsHglxi1uHMdO4GwhNqk1AQSArht1iYrW5s1XddtbUbadVnajo1mTVjyb0+nu5PvHlmyRDDBWL/kY1vnu9Ojr+90d48eCYQCBZpwKYryuk0YT0WTsxjjej7A51fFME5VjPfMNC68blvGTEVc4h+n6uXXacnYqYijwlYAz4+WQuS1V12lmzjxOo0ZL8WXyKteff8C3c7gYSVy0ag2WpvGRfNV+v4mY4euFN2yZ8p4NjyD60HrNFRjbchiFwo5Z9ZmcCJL3uM1nBu1ZWdeuSvsg8UuU3fMrOCk9TmOXdvnJMjOLj7rBEWTxpHcxLe8Ae0OhzGeDoUqlQrIm6QtUi/SLxILp2LhGRZmhCx2kTyaqiRCIWORNlNLqiriCzUNk1Mduv5B6MM7tGgUTbaSKfr+G84O9ycg0WgqksR4ab5ejVdRgk6bPzIyfrxCPqlJNNnKgflcaNaWpVKNz8fmMc6QDZ283r1HPmaHTgXPu2IlcSvrPALgKf5J/y1dhOCJ97tcESZ0Gs475uuz+2SPpUw8O3Qlxqmk3FazfFRBn/yOpwTsUAin89ForoRn3KZsBda5P+bo4rFRGzYWypRr4XC95JqHDQ1f/j4UKq2TT/XqyO0aGxWxm3+kUjDPhVpxqlgskpkeHKEnW9OOLvepQhiXEjLbcGr0Fo2Ppga3JC0Rw9NxRNb/2X7qgou/ZRI1beeRTdQpOKIqLrGmp+IAnawKnHVE0zicUcQMOJZX82WcnvS1rF3SIiMTwbOq7EzJYS1ejkTyWRQIqmINB9EITqu2cXc2c8oGjZPoBLiSxEulAYuGfPi07RkrYa1SqOHQYN8xDpqdiyrTC7jktDJTp0/VlrGSlsC47Lxa0HAwRAwWn8gVHFe1kchp2nPmlFNnwrVBfTJfx2U2kXNa1WYnutkllnAhF82lFrAqpZsTOWsr5XAZouzsFj3/imC+tsos9M/6tomcMviq9fBAlXOspHgVh8WKGeDCKpzIpeyXewzVJrjZqXK7SReIRw6HpgZkHXThNbM0GrPGQuwS4c305hz5kMOzjhO5woCGN8nhJ5m0+fbpPdT+zPw07eK6tF9oDKVHY9ZYqGServT7xssfzBNcfN45c8pGaqIDd/isTd/5nF3nchs34Rkv4n4Z6JyLT2z16IPP5miKS25VbngV16tA517C0X9xj6a4ZicjSzEapcSHXH0870qbw2z7bcQjcaKuvjg1nYuQyOKldD64mpink+HP95T2O2afTbpeItQwTpE2p2RmcWZhwi9is5W8frN8yRxmNQzDOiWJizY88d7iiDwnibj6MZfEq9yVwF1cE6+oppbcRs6C3NIm2g1AtZDkvJSSe/iXtQDrXaMlJ/yEZ2iarmBzIVx3RWfdYqH/kbILosVILNMMxrhWGOQ8EVTg7qYv/0TZKRPtMrbk5d72GbYi2//qz5SdEC8byF3s6n/rL3NfBux8irW7j1dQ0O78iq5BerFY7K9fm7esRGuv16AxkmLN51ifLQchnp4V49PojnkTymRfmfWpKfn8NuEuKJ+Kipd20sGzK3wpisusnybwZIehHEPZMk7nVTW5FJ54J8pxlClHIqqrly9QoECBAgUaA+lTxWIwnh1Pb7wTCn349YXhGcdRy98g1H64Oqrq3yBX65t/G1n9NukfnNqu0PJ36NZno6veZIf23x7dHoD28cqp7Wv50e5XI6yeslse4a8D9G3m9Pa1jO+MsnrKrvGdldBbBzn0hJzSSczBSnx4xdtfoX9JDa+lwup6eekM0s3bzsZZmwWDtfz3RyBn9/6QvYFNIsejo+za/aat/RrkWJxbOxIrv9bYBDnaPnr8p3fiD+R+9Nav5Bz7e2hb2GzdR3cBPL3u8fS8/P0+bOSLF+XtWyuNl+Le1tFNUHnrZ6fqTXatj/rW6YCdHkWNLSlh50jO0frHY6fabbr+c7wa/1ZiAdnl4AH2noC2cvufXtl9hw6/l5MguyhCcvW9bTkD+uFHp+rJHOXyjNCLIDtDz+XfvfuT/PXlhnd2Zn/dlxoeZGe0Y7k+7YE8urTvwabhJIMduiu3csgOoYM9eW8b8tEerDg+nYDMjaUQfDu7RamyjPG7S0d78PbBI69TnOv/NnfxvlijjV1POsF3L6C1d8WExgfxDz0O1Q3SQ3akzDZ2B1Ll3VX0H4ll82E85nn2a+uzb96prgvbvcIL0GfRsufzXbfCLezrPcDu4J2qeL5ubCe2pU6lINspyYcgu8Of4+LY19rubMK9gW4W6EQVDQEV/Cf4uu0LFh5evy1DyPP1x+zQvRWG782x9tSMnLkQngZ14RKoC4Pqy75uwMGgtgisLjY71CLPE8spWPl0DVQ+GwMJOAL35swOXggtw6BBW5QwrCzqjx3YzsHQYtszPe0W+WAHEqrw4mVJBQm2h8q5sIOWTsNn+UFLNVhZ5pXY2QJP/FvkLBu7BIx5tsXeh+EdlQE7poBdwI6Ks+vwqfo4sNtZJ6/M0paaYhNPZmlv6+aKZOnB1Zt0os3Z3TwK0SIe2fUKoimHvDRn173K8nGLSjtPJYu6/+WzaS/seuYYwNm9yJfo3vrsdukyhrHrbu2wdQVnZ+1uELvr7wqWLs7pLyVLjVn1E9HSxi9Ip8tlxu6Ne+g6XWl4bXeLc31T1h6jJi3N2TUBO2MRsbEqWtRfxXlqd2YtjF1znR2twK51iWaj7ErW4Vrt7j2v7LKowdYg1FJ9y1i/XhQsXbtj7gBZ7Pb3UJP+dMdh195DLVrakd1FdGtFsMgvO9PYfp+9TTuNCzu2XPfPDqEfpD5L2G2I7JYfG0sCc7vf7tjhHoedUZoZ79Ludq8JFr0au0PWIym7bn4dsDNW82/RwzXZdYyltXd2l7nXgFm6e6G5KVm6sdqmN8EydkYPPqTt4jjslBI6oKWd2PUsX+gJsOPoHNvd7gp37Xpqd82nfUv155e414Rb2rkvW6rnWQY+VrTybAbuld2GwM4YnFhpa47Cb8Lgv2YvPydb1OO+EE/szJGJseuqVWZsn51OGfFxtsO98ha7HksYgznKK1jkrAmZ372CRc4K2J1ZdmfPjzLcouOzi5+kH0XFM2FRM0sLIAGHgWCJBV+3a8LSNVt1S0Mt8sHOf+U1mOBYe2o6FxWVixVAAo5L29EMBhlU5z8vNoidXDqar4HqSuWhFvlgB4oWYiChXAIJtbxsn8sTM2xnl7Lt7AL6rHKy5zsPvs8TPN9Vg7HC686CcTZg52DKWLLLmM5GbmmX30vjaGmGOSc5Oz3DvAce2bE9sNJdPhXg7FoZtgZiFnVD/GIz9yhaswlP/rt18tpn16PPauHsunxvFrsWA9Bn16uIBgvSQ6vmYpyvvK92tyRLUZf7cbkv4AKL4OC+gNIqC+Hwxm5/b21TMCXLbxlj7FqbWeae5L+mdSmfW3SZV+WB3cGKGcUltDtamrFrPtVLFJ7FTlsU/CimetQ7YWfXWqeeCyePT+dp70i0dPmXAT4o6k/0xq7KHCncFD4DZuwOnvGIEEd21pzZA7v71JfpxM44/iRgh96D7JpO7BCLc+Ls5qCnEck+KBJYI/s+V/z6PmmckwO7u9e4a/dE2Bk/BvGYUXat/P05yK6XpK38eOyerwiWknYne7hbL6R21zDaHfS5N3353Nubkin+2501hnhh1zZ/CKd2VzH93malJjvT1ymyI95RR3b683fNGyyYpc1L3UuSpVngc0eH68xZyceKjdxNP9d62g+niqIp4Hynl3JscODsNsBYgayHbUnstKmKpSnrQSwHP5p7E9jRoYCxax91t4/fZ/ViMSewQy0+7jFLN3Jd2W+M+L0s1jib8zXOTk3lcqIpPB6Hj7N6Th5n+3Kfo9zAgp7xVOPoADsq3mez/HD77JhBwhyFphxjftfjk5YzPr/LiotPGKAXzI3P3tyYKmAHEvyxU0Sh6TxIwEVpW8likEFmdyM8ayk8IGQXlo6GQYIHi/ywk4sa7OQEg52cYLADe3OsXcWvLsn3mYkkLUUGsTsBiewqcUH2890JyJGd3eceBwm2J+ScrM+9+Io+9xviYT4DOUfrcx//853UwYCCseIMjxWyAnZwb461B+xAghd2vdQLwX+HOqocu4h2eDgIszTLDebsuuo6/eCNnR5KXBVMafLSVuwiP2k7WaRDi9zUCnVIuA1n11MZEc/sWnn+iw1gV0Fm5A+z1Fjns78kydezqy15PVvh9/0xdsbXB37ioJRVelMnLd3Y5o4M7gtgYVI+LHKTNoeer/ZjFzfRIYy/26Erfc5ul99fxtgtrq6xWwMH9dnW8z0k+qBuib5PW/wdso7t2PF3nYd9U2zxd2uQnQeLXHVI7nZj7Paf8Rv7nGLIUIuHsFF2y3eMvdGEwee7Hy5Kvk9o6W1XdkazWfPn+6QtrR/3OYQd8MYOsMhdpDRjZ3wcxq4psyOHtuH4B0u258z4YWap0aTl6N5t7up0Yrd2hK7TXufRf3ePsuiXluKNG5CdB4tcZPT43X6fNfbNzhBOcZ+QHXrZ35u9dl1NrPYtbYVAVHlza0eOc4fs0MFRiqZ4bHcd+gCCfmk5zh2y82CR697Mxw3wsWL3PkPk3O6Y65eza196wRaUJzFHgeOspfGco7TWzTfrfLfO0oP5HVMwNx4bdkNjF89XHFTJxs6HHyWWER1g8Uy9FJcTsConVLFcIl7wF38nF46nFkB1yfmhFvlgByov1UHl8xFQeS0FDHTxfV6Zj4maX5iNyQm4LifEsFwilvbHDpSuw4SZ2lCLfLADlc8ugMprMyBhCRzuvB/f57mONw7u2z6rY0XADu7NsfaAHUjwxu666L+zNEJ2R4NMGRU7HcTfUZ0QO/1/AjslxBeL/C7pUIqv56ilvaMCXYDy2EW1wwKlvLK7+71gSvcJu02Qs7Ouxnm2yF1fCD4oYj4NzezH3y1StxFjZ6yeWeWcXYPfeziI3W3RbzzUa6G/ROwuScaOeCro4Xtkt7Z1p29Kw7qjk8d9/sD+Ts/J+FFQu0Bcl86xi9zlxthtzPHKGTt9m/jJ+gbLld9rC+yG+u+IF1WKXTT0xE8Mmf4TEmJm1yA7Hnbqx6PootY3DV/sbPdt60WX2MVO9cFjH5ba7ts2vmd9yhu7br5jPjb3dNj1Ep1Hlv/OFvfZy18YwA7E3+ll2jQGjhVNIWbW6IGX5wRLjUbckK8ObHM3sfWcCv6AOc9jxbpoyjB2xCKpz9oscleD7M17n13V2fMSODud9SoPc5SdHWY7vyqV4k+jY5Y2U+xxY4xdb4s/r+54c5QbLCTWid1wizxIYEet77PrSex0lV+V49fJvr2aiEoG23Vm5nddHiI7FvM7U2eG3StY5KyA3ZllF/hRZPnxoywkI6KSC/WInIDLckIEyyUiMX/sQOlpkJBM14Za5IMd2FsdHm44DRLwPNybY+05FSjvPwFGO7oKFh5evy2D6vaHuyVpQ/c2/OhgwwwUaIA0Egnab5iapplpsqQIUYV+n1XMjBpSjE9GDVnyppjJk/J3NQ1YSjarZY2D14wNZHxS2GeDjLFhfmO8GmTYR0WjOc33rEEvSzdJBuOdpE2GskZLUSgJ0pAUxUgg2LLGO2lOCkFJUulH8p25ZcIidHlTJV9Sqprn8+uYi7EzWpNCWBEGpOWZ+BTjG0Uxv88SrCSdfIVYdsaOQSYNMmtmzw7/Y+vnQgr5Z3ZJTaEbGnvR6AnM+sYEYn5BWiBJRPS/xr8hYskTpAFHq0zKWStQoECm/g+AcAmRda07LQAAAABJRU5ErkJggg==" alt=""></p>
<h1 id="2-基尔霍夫矩阵性质"><a href="#2-基尔霍夫矩阵性质" class="headerlink" title="2.基尔霍夫矩阵性质"></a>2.基尔霍夫矩阵性质</h1><p>对于任意一个图 𝐺，其基尔霍夫矩阵 𝐾 具有以下性质：</p>
<p>1.基尔霍夫矩阵 𝐾 的每一行或每一列上的元素和都是 0<br>2.基尔霍夫矩阵 𝐾 的行列式的值为 0<br>3.基尔霍夫矩阵 𝐾 的任意一个代数余子式值都相同<br>4.如果图 𝐺 不连通，基尔霍夫矩阵 𝐾 的任意主子式行列式值为 0<br>5.如果图 𝐺 是一棵树，基尔霍夫矩阵 𝐾 的任意一个 𝑛−1 阶主子式的行列式为 1</p>
<h1 id="3-Matrix-Tree-定理"><a href="#3-Matrix-Tree-定理" class="headerlink" title="3.Matrix-Tree 定理"></a>3.Matrix-Tree 定理</h1><p>Matrix-Tree 定理的内容为：对于已经得出的基尔霍夫矩阵，去掉其随意一行一列得出的矩阵的行列式，其绝对值为生成树的个数</p>
<p>因此，对于给定的图 𝐺，若要求其生成树个数，可以先求其基尔霍夫矩阵，然后随意取其任意一个 𝑛−1 阶行列式，然后求出行列式的值，其绝对值就是这个图中生成树的个数。</p>
]]></content>
  </entry>
  <entry>
    <title>子串的最大差</title>
    <url>/2022/02/27/%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE/</url>
    <content><![CDATA[<p><a href="http://oj.daimayuan.top/problem/436">#436. 子串的最大差</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个数组，求所有区间的（最大值-最小值）的和。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于每个数计算它的贡献。贡献分为两部分，一部分是作为最大值，一部分是作为最小值。当a[i]作为最大值，你要找到它左边第一个大于等于（可能存在连续相等的数，避免重复左闭右开）他的数位置l和右边第一个比他大的数位置r，那么当前树的贡献是a[i] <em> （i-l）</em> （r-i）。最小值同理不过是减去。</p>
<p>这里介绍两种寻找每个数的l，r的方法。</p>
<ol>
<li>单调栈<br>好像就相当是个板子了</li>
<li>二分+st表<br>对于每个数a[i]二分它的左边【0，i-1】和右边[i+1,N]，然后用st表来check。一段区间的前缀或后缀的最值是单调的，满足二分。</li>
</ol>
<h3 id="单调栈代码"><a href="#单调栈代码" class="headerlink" title="单调栈代码"></a>单调栈代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N+<span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cin &gt;&gt; a[i];</span><br><span class="line">	a[<span class="number">0</span>] = a[N+<span class="number">1</span>] = <span class="number">1e9</span>;<span class="comment">//设置哨兵，</span></span><br><span class="line">		</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxl</span><span class="params">(N+<span class="number">2</span>)</span>,<span class="title">maxr</span><span class="params">(N+<span class="number">2</span>)</span>,<span class="title">minl</span><span class="params">(N+<span class="number">2</span>)</span>,<span class="title">minr</span><span class="params">(N+<span class="number">2</span>)</span></span>;</span><br><span class="line">	stack&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;<span class="comment">//pair是值和位置</span></span><br><span class="line">	</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(a[<span class="number">0</span>], <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N + <span class="number">1</span>; i ++) &#123;<span class="comment">//i is max</span></span><br><span class="line">		<span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">top</span>().first &lt; a[i]) &#123;</span><br><span class="line">			maxr[q.<span class="built_in">top</span>().second] = i;<span class="comment">//a[i]作为栈顶右边的最大值</span></span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (q.<span class="built_in">size</span>()) maxl[i] = q.<span class="built_in">top</span>().second;<span class="comment">//栈顶作为a[i]左边的最大值</span></span><br><span class="line">		q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(a[i], i));<span class="comment">//a[i]入栈</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();<span class="comment">//清空栈内元素	</span></span><br><span class="line">	a[<span class="number">0</span>] = a[N+<span class="number">1</span>] = <span class="number">-1e9</span>;<span class="comment">//哨兵</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(a[<span class="number">0</span>], <span class="number">0</span>));</span><br><span class="line">	<span class="comment">//求最小值同理</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N + <span class="number">1</span>; i ++) &#123;<span class="comment">//i is min</span></span><br><span class="line">		<span class="keyword">while</span> (q.<span class="built_in">size</span>() &amp;&amp; q.<span class="built_in">top</span>().first &gt; a[i]) &#123;</span><br><span class="line">			minr[q.<span class="built_in">top</span>().second] = i;</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (q.<span class="built_in">size</span>()) minl[i] = q.<span class="built_in">top</span>().second;</span><br><span class="line">		q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(a[i], i));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;<span class="comment">//枚举每个位置的贡献</span></span><br><span class="line">		<span class="keyword">int</span> r = maxr[i] - i;</span><br><span class="line">		<span class="keyword">int</span> l = i - maxl[i];</span><br><span class="line">		<span class="keyword">int</span> cnt = r * l;</span><br><span class="line">		r = minr[i] - i;</span><br><span class="line">		l = i - minl[i];</span><br><span class="line">		ans += a[i] * cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="二分-st表代码"><a href="#二分-st表代码" class="headerlink" title="二分+st表代码"></a>二分+st表代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K,Q;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(maxn)</span>, <span class="title">dp</span><span class="params">(maxn)</span>, <span class="title">f</span><span class="params">(maxn)</span>, <span class="title">B</span><span class="params">(maxn)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a, b, c, x, t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RMQ</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highest_bit</span><span class="params">(<span class="keyword">unsigned</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">31</span> - __builtin_clz(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;T&gt;&gt; range_max;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">RMQ</span>(<span class="keyword">const</span> vector&lt;T&gt; &amp;values = &#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!values.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">build</span>(values);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">better</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> vector&lt;T&gt; &amp;values)</span> </span>&#123;</span><br><span class="line">        n = (<span class="keyword">int</span>)(values.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">int</span> levels = <span class="built_in">highest_bit</span>(n) + <span class="number">1</span>;</span><br><span class="line">        range_max.<span class="built_in">resize</span>(levels);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; levels; k++)</span><br><span class="line">            range_max[k].<span class="built_in">resize</span>(n - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            range_max[<span class="number">0</span>] = values;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; levels; k++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; k); i++)</span><br><span class="line">                range_max[k][i] = <span class="built_in">better</span>(range_max[k - <span class="number">1</span>][i], range_max[k - <span class="number">1</span>][i + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">T <span class="title">query_value</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span> </span>&#123;<span class="comment">//[a,b),idx from 1</span></span><br><span class="line">        <span class="comment">// assert(0 &lt;= a &amp;&amp; a &lt; b &amp;&amp; b &lt;= n);</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="built_in">highest_bit</span>(b - a + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">better</span>(range_max[level][a], range_max[level][b - (<span class="number">1</span> &lt;&lt; level) + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RMQ1</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highest_bit</span><span class="params">(<span class="keyword">unsigned</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">31</span> - __builtin_clz(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;T&gt;&gt; range_min;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">RMQ1</span>(<span class="keyword">const</span> vector&lt;T&gt; &amp;values = &#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!values.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">build</span>(values);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">better</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> vector&lt;T&gt; &amp;values)</span> </span>&#123;</span><br><span class="line">        n = (<span class="keyword">int</span>)(values.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">int</span> levels = <span class="built_in">highest_bit</span>(n) + <span class="number">1</span>;</span><br><span class="line">        range_min.<span class="built_in">resize</span>(levels);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; levels; k++)</span><br><span class="line">            range_min[k].<span class="built_in">resize</span>(n - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            range_min[<span class="number">0</span>] = values;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; levels; k++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; k); i++)</span><br><span class="line">                range_min[k][i] = <span class="built_in">better</span>(range_min[k - <span class="number">1</span>][i], range_min[k - <span class="number">1</span>][i + (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">T <span class="title">query_value</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span> </span>&#123;<span class="comment">//[a,b),idx from 1</span></span><br><span class="line">        <span class="comment">// assert(0 &lt;= a &amp;&amp; a &lt; b &amp;&amp; b &lt;= n);</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="built_in">highest_bit</span>(b - a + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">better</span>(range_min[level][a], range_min[level][b - (<span class="number">1</span> &lt;&lt; level) + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(N+<span class="number">2</span>)</span>, <span class="title">sum</span><span class="params">(N+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) cin &gt;&gt; a[i];</span><br><span class="line">	a[<span class="number">0</span>] = a[N+<span class="number">1</span>] = <span class="number">1e9</span>;</span><br><span class="line">	<span class="function">RMQ&lt;<span class="keyword">int</span>&gt; <span class="title">rmq</span><span class="params">(a)</span></span>;<span class="comment">//维护区间最大</span></span><br><span class="line">	a[<span class="number">0</span>] = a[N+<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="function">RMQ1&lt;<span class="keyword">int</span>&gt; <span class="title">rmq1</span><span class="params">(a)</span></span>;<span class="comment">//维护区间最小</span></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;<span class="comment">//max</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//二分求右边界</span></span><br><span class="line">		<span class="keyword">int</span> l = i + <span class="number">1</span>, r = N+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (rmq.<span class="built_in">query_value</span>(i + <span class="number">1</span>,mid) &gt; a[i]) r = mid ;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				l = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> right = l - i;<span class="comment">//暂存右边界的长度</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//二分左边界</span></span><br><span class="line">		l = <span class="number">0</span>, r = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (rmq.<span class="built_in">query_value</span>(mid, i - <span class="number">1</span>) &lt; a[i]) r = mid - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				l = mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += right * (i-r) * a[i];<span class="comment">//计算贡献</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;<span class="comment">//min同理</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> l = i + <span class="number">1</span>, r = N+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (rmq1.<span class="built_in">query_value</span>(i + <span class="number">1</span>,mid) &lt; a[i]) r = mid ;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				l = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> right = l - i;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		l = <span class="number">0</span>, r = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (rmq1.<span class="built_in">query_value</span>(mid, i - <span class="number">1</span>) &gt; a[i]) r = mid - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				l = mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ans -= right * (i-r) * a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i ++) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>namomo每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>template</title>
    <url>/2022/04/13/template/</url>
    <content><![CDATA[<h1 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line"></span><br><span class="line">string，字符串</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br><span class="line"></span><br><span class="line">queue, 队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br><span class="line"></span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入一个数</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span>  查找一个数</span></span><br><span class="line"><span class="function">        <span class="title">count</span><span class="params">()</span>  返回某一个数的个数</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x   <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    map/multimap</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入的数是一个pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">    和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">    bitset&lt;10000&gt; s</span>;</span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="log预处理"><a href="#log预处理" class="headerlink" title="log预处理"></a>log预处理</h1><script type="math/tex; mode=display">
\left\{\begin{aligned} Logn[1] &=0, \\ Logn\left[i\right] &=Logn[\frac{i}{2}] + 1. \end{aligned}\right.</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getlog</span><span class="params">()</span></span>&#123;<span class="comment">//预处理Log数组</span></span><br><span class="line">	Log[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h1><p><strong>用处：</strong></p>
<p>静态区间最大值，最小值，gcd（可重复贡献的问题）除 RMQ 以外，还有其它的“可重复贡献问题”。例如“区间按位和”、“区间按位或”、“区间 GCD”，ST 表都能高效地解决。例如“区间按位与”就是每一位取最小值，“区间按位或”就是每一位取最大值，而“区间 GCD”则是每一个质因数的指数取最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N];<span class="comment">//静态数组</span></span><br><span class="line"><span class="keyword">int</span> Log[N];<span class="comment">//log(i)的值</span></span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">20</span>];<span class="comment">//区间【i，i+(2^j)-1】里的信息（最值，gcd等）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getlog</span><span class="params">()</span></span>&#123;<span class="comment">//预处理Log数组</span></span><br><span class="line">	Log[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		Log[i] = Log[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j)&lt;= n; j ++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span> &lt;= n; i++)&#123;</span><br><span class="line">      <span class="comment">//由原来两半得到合并后长度的信息（类似区间dp）</span></span><br><span class="line">			dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    	cin &gt;&gt; a[i];</span><br><span class="line">    	dp[i][<span class="number">0</span>] = a[i];<span class="comment">//区间长度为1时就是自己</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getlog</span>();</span><br><span class="line">    <span class="built_in">RMQ</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    	<span class="keyword">int</span> l,r;</span><br><span class="line">    	cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    	<span class="keyword">int</span> e = Log[r-l+<span class="number">1</span>];</span><br><span class="line">      <span class="comment">//从前2^e和从后2^e囊括了整个区间</span></span><br><span class="line">    	cout &lt;&lt; <span class="built_in">max</span>(dp[l][e],dp[r-(<span class="number">1</span>&lt;&lt;e)+<span class="number">1</span>][e]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="Lca"><a href="#Lca" class="headerlink" title="Lca"></a>Lca</h1><p>倍增法求公共祖先</p>
<p><strong>用处：</strong></p>
<p>1 -  求树上两点最短距离</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; g[N];<span class="comment">//存图</span></span><br><span class="line"><span class="keyword">int</span> deep[N];<span class="comment">//节点的深度</span></span><br><span class="line"><span class="keyword">int</span> pre[N][<span class="number">64</span>];<span class="comment">//i节点往上2^j层节点编号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	deep[u] = deep[fa]+<span class="number">1</span>;<span class="comment">//深度是父节点深度+1</span></span><br><span class="line">	pre[u][<span class="number">0</span>] = fa;<span class="comment">//往上2^0=1层就是父节点</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">//往上2^j层是往上2^(j-1)后再往上2^(j-1)层</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j) &lt;= deep[u]; j ++)&#123;</span><br><span class="line">		pre[u][j] = pre[pre[u][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(g[u][i]==fa) <span class="keyword">continue</span>;<span class="comment">//不能往回走</span></span><br><span class="line">		<span class="built_in">init</span>(g[u][i],u);<span class="comment">//dfs递归</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(deep[u] &lt; deep[v]) <span class="built_in">swap</span>(u,v);<span class="comment">//保证u的深度&gt;=v的深度</span></span><br><span class="line">	<span class="keyword">int</span> d = deep[u] - deep[v];<span class="comment">//深度差</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (<span class="number">1</span>&lt;&lt;i) &lt;= d; i ++)&#123;<span class="comment">//将深度差转化成2进制</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;d) u = pre[u][i];<span class="comment">//第i位是1说明d由2^i累加</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;<span class="comment">//已经相等了，直接返回（v，u同一条链）</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">63</span>; i &gt;= <span class="number">0</span>; i --)&#123;<span class="comment">//u，v同时往上跳</span></span><br><span class="line">    <span class="comment">//公共祖先及以上是相等，可能跳过，所以用不相等判断</span></span><br><span class="line">		<span class="keyword">if</span>(pre[u][i]!=pre[v][i])&#123;<span class="comment">//还没跳到公共祖先</span></span><br><span class="line">			u = pre[u][i];</span><br><span class="line">			v = pre[v][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//结束后是公共祖先的子节点	</span></span><br><span class="line">	<span class="keyword">return</span> pre[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="悬线法"><a href="#悬线法" class="headerlink" title="悬线法"></a>悬线法</h1><p>求最大子矩阵（要求每个矩阵底边在同一行）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhujuqiang/blog_img/jVqWdfCBgI21TbK.png" alt="iShot2021-10-20 17.08.50.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::max;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N];</span><br><span class="line"><span class="keyword">int</span> l[N], r[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF &amp;&amp; n) &#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//a[i]是每一列的高度， l[i],r[i]分别指以a[i]为高的矩阵的左边界和右边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), l[i] = r[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//l[i]--i是单调减的</span></span><br><span class="line">      <span class="keyword">while</span> (l[i] &gt; <span class="number">1</span> &amp;&amp; a[i] &lt;= a[l[i] - <span class="number">1</span>]) l[i] = l[l[i] - <span class="number">1</span>];<span class="comment">//计算左边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)<span class="comment">//i--r[i]i是单调增的</span></span><br><span class="line">      <span class="keyword">while</span> (r[i] &lt; n &amp;&amp; a[i] &lt;= a[r[i] + <span class="number">1</span>]) r[i] = r[r[i] + <span class="number">1</span>];<span class="comment">//计算右边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//枚举取Max</span></span><br><span class="line">      ans = <span class="built_in">max</span>(ans, (<span class="keyword">long</span> <span class="keyword">long</span>)(r[i] - l[i] + <span class="number">1</span>) * a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2021杭电多校第一场-Maximal-submatrix"><a href="#2021杭电多校第一场-Maximal-submatrix" class="headerlink" title="2021杭电多校第一场    Maximal submatrix"></a><a href="https://acm.hdu.edu.cn/showproblem.php?pid=6957">2021杭电多校第一场    Maximal submatrix</a></h4><p>枚举每一行为底边就转化成上述的子问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N][N], g[N][N], l[N], r[N], h[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">    		cin &gt;&gt; a[i][j];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">    	<span class="keyword">int</span> t = <span class="number">1</span>, x = <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">while</span>(t&lt;=n)&#123;</span><br><span class="line">    		x = <span class="number">1</span>-x;</span><br><span class="line">    		<span class="keyword">while</span>(a[t][i]&lt;=a[t+<span class="number">1</span>][i])&#123;</span><br><span class="line">    			g[t][i] = x;</span><br><span class="line">    			t++;</span><br><span class="line">    			<span class="comment">//if(t&gt;n) break;</span></span><br><span class="line">    		&#125;</span><br><span class="line">    		g[t][i] = x;</span><br><span class="line">    		t++;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) h[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) l[j] = r[j] = j;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(g[i][j]==g[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">    			h[j]++;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">else</span>&#123;</span><br><span class="line">    			h[j] = <span class="number">1</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">    		<span class="keyword">while</span>(l[j]&gt;<span class="number">1</span> &amp;&amp; h[j]&lt;=h[l[j]<span class="number">-1</span>]) l[j] = l[l[j]<span class="number">-1</span>];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j --)&#123;</span><br><span class="line">    		<span class="keyword">while</span>(r[j]&lt;m &amp;&amp; h[j]&lt;=h[r[j]+<span class="number">1</span>]) r[j] = r[r[j]+<span class="number">1</span>];</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">    		ans = <span class="built_in">max</span>(ans, h[j]*(r[j]-l[j]+<span class="number">1</span>));</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h1><p>用于求解下述式子</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhujuqiang/blog_img/20220420231215.png" alt=""></p>
<p><strong>算法描述</strong></p>
<p>令 $ x = A \left \lceil \sqrt p \right \rceil - B $，其中 $0\le A,B \le \left \lceil \sqrt p \right \rceil$，则有 $a^{A\left \lceil \sqrt p \right \rceil -B} \equiv b \pmod p$，稍加变换，则有 $a^{A\left \lceil \sqrt p \right \rceil} \equiv ba^B \pmod p$。</p>
<p>我们已知的是 $a,b$，所以我们可以先算出等式右边的 $ba^B$的所有取值，枚举 $B$，用 <code>hash</code>/<code>map</code> 存下来，然后逐一计算 $a^{A\left \lceil \sqrt p \right \rceil}$，枚举 $A$，寻找是否有与之相等的 $ba^B$，从而我们可以得到所有的 $x$，$x=A \left \lceil \sqrt p \right \rceil - B$。</p>
<p>注意到 $A,B$ 均小于 $\left \lceil \sqrt p \right \rceil$，所以时间复杂度为 $\Theta\left (\sqrt p\right )$，用 <code>map</code> 则多一个 $log$。</p>
<p><strong>工具</strong></p>
<ol>
<li>map哈希</li>
<li>分块</li>
</ol>
<h4 id="简单计算机（模板题）"><a href="#简单计算机（模板题）" class="headerlink" title="简单计算机（模板题）"></a>简单计算机（模板题）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bsgs</span><span class="params">(ll a, ll b, ll p)</span></span>&#123;</span><br><span class="line">  <span class="comment">//特判a==0的情况</span></span><br><span class="line">	<span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Orz, I cannot find x!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));<span class="comment">//分块</span></span><br><span class="line">	unordered_map&lt;ll,ll&gt; dis;<span class="comment">//记录  dis[(b*a^B)%p] = B</span></span><br><span class="line">	</span><br><span class="line">	ll temp = b%p;</span><br><span class="line">	dis[temp] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">		temp = (temp*a)%p;</span><br><span class="line">		dis[temp] = i;<span class="comment">//预处理dis</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ll t = <span class="built_in">qmi</span>(a,m,p);</span><br><span class="line">	temp = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">		temp = (temp*t)%p;</span><br><span class="line">		<span class="keyword">if</span>(dis[temp])&#123;</span><br><span class="line">			ll x =i*m-dis[temp];<span class="comment">//计算x</span></span><br><span class="line">			x = (x%p+p)%p;<span class="comment">//可能变负数，取正</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,x);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Orz, I cannot find x!&quot;</span>);<span class="comment">//无解</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h1><p>用分治思想处理树上的一些问题，即根节点信息可以由所有子节点的信息推出</p>
<blockquote>
<p>求树上长度等于k的路径有几条</p>
</blockquote>
<p><strong>第一步：求出树的重心</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pre)</span> <span class="comment">//siz:树的大小,mx:子树中size的最大值,root树的重心</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  siz[x] = <span class="number">1</span>;<span class="comment">//当前节点大小为1</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = h[x]; i!=<span class="number">-1</span>; i = ne[i])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(to[i]!=pre)<span class="comment">//不能往回走，所以到父亲节点时跳过</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">getroot</span>(to[i],x);<span class="comment">//递归求子树</span></span><br><span class="line">      siz[x] += size[to[i]];</span><br><span class="line">      mx[x] = <span class="built_in">max</span>(mx[x], size[to[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mx[x] = <span class="built_in">max</span>(mx[x], n-siz[x]);</span><br><span class="line">  <span class="keyword">if</span>(mx[x]&lt;mx[root]) root = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二步：以新的root为根</strong></p>
<h1 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h1><p>顾名思义，一条线在整个图上扫来扫去。</p>
<p><strong>模型：</strong>在二维坐标系上，给出多个矩形的左下以及右上坐标，求出所有矩形构成的图形的面积。它一般被用来解决图形面积，周长等问题。</p>
<p><strong>思路：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhujuqiang/blog_img/20220420231518.png" alt=""></p>
<ul>
<li>如图所示，我们可以按照每一种y画一条横线（这就是扫描线），把整个矩形分成如图各个颜色不同的小矩形，那么这个小矩形的高就是我们扫过的距离，那么剩下了一个变量，那就是矩形的长一直在变化（若干个区间并集的长度）。</li>
<li>我们的线段树就是为了维护矩形的长，我们给每一个矩形的上下边进行标记，下面的边标记为 1，上面的边标记为 -1，每遇到一个矩形时，我们知道了标记为 1 的边，我们就加进来这一条矩形的长，等到扫描到 -1 时，证明这一条边需要删除，就删去，利用 1 和 -1 可以轻松的到这种状态。（最后标记大于0的集合就是区间并集，也就是长）</li>
<li>还要注意这里的线段树指的并不是线段的一个端点，而指的是一个区间，所以我们要计算的是r+1和r-1 。</li>
<li>需要 离散化</li>
</ul>
<h4 id="模板：牛客多校6H-Hopping-Rabbit"><a href="#模板：牛客多校6H-Hopping-Rabbit" class="headerlink" title="模板：牛客多校6H_Hopping Rabbit"></a>模板：<a href="https://ac.nowcoder.com/acm/contest/11257/H">牛客多校6H_Hopping Rabbit</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> yl,yr;<span class="comment">//	矩形左边界，右边界</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span>&#123;</span><span class="comment">//		存储线段信息</span></span><br><span class="line">	<span class="keyword">int</span> mi[N*<span class="number">4</span>],lazy[N*<span class="number">4</span>]；</span><br><span class="line">  <span class="keyword">int</span> L,R,W;	<span class="comment">//左端点，右端点，修改的值</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		mi[x]=<span class="built_in">min</span>(mi[x&lt;&lt;<span class="number">1</span>],mi[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(lazy[x])&#123;</span><br><span class="line">			lazy[x&lt;&lt;<span class="number">1</span>]+=lazy[x],mi[x&lt;&lt;<span class="number">1</span>]+=lazy[x];</span><br><span class="line">			lazy[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[x],mi[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[x];</span><br><span class="line">			lazy[x]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;mi[x]+=W,lazy[x]+=W;<span class="keyword">return</span>;&#125;</span><br><span class="line">		<span class="built_in">pushdown</span>(x);</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid)<span class="built_in">change</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">		<span class="keyword">if</span>(R&gt;mid)<span class="built_in">change</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="built_in">update</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;<span class="built_in">pushdown</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(!mi[x&lt;&lt;<span class="number">1</span>])<span class="keyword">return</span> <span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(mi[<span class="number">1</span>])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n)<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;S;</span><br><span class="line">vector&lt;A&gt; V[N],V1[N];</span><br><span class="line"><span class="keyword">int</span> n,d;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	x=(x%d+d)%d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">op1</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y1,<span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x1&gt;=x2||y1&gt;=y2)<span class="keyword">return</span>;</span><br><span class="line">	V[x1].<span class="built_in">push_back</span>(A&#123;y1+<span class="number">1</span>,y2&#125;);</span><br><span class="line">	V1[x2].<span class="built_in">push_back</span>(A&#123;y1+<span class="number">1</span>,y2&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">op</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y1,<span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(y2-y1&gt;=d)&#123;<span class="built_in">op1</span>(x1,x2,<span class="number">0</span>,d);<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="built_in">cal</span>(y1),<span class="built_in">cal</span>(y2);</span><br><span class="line">	<span class="keyword">if</span>(y1&gt;y2)&#123;<span class="built_in">op1</span>(x1,x2,y1,d),<span class="built_in">op1</span>(x1,x2,<span class="number">0</span>,y2);&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">op1</span>(x1,x2,y1,y2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x1,y1,x2,y2;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;d);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">    <span class="comment">//取模离散化到小范围可能变成多个矩形</span></span><br><span class="line">    <span class="comment">//以下及op函数都在处理该问题</span></span><br><span class="line">		<span class="keyword">if</span>(x2-x1&gt;=d)&#123;<span class="built_in">op</span>(<span class="number">0</span>,d,y1,y2);<span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="built_in">cal</span>(x1),<span class="built_in">cal</span>(x2);</span><br><span class="line">		<span class="keyword">if</span>(x1&gt;x2)&#123;<span class="built_in">op</span>(x1,d,y1,y2),<span class="built_in">op</span>(<span class="number">0</span>,x2,y1,y2);&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">op</span>(x1,x2,y1,y2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++)&#123;<span class="comment">//枚举每个（扫描）线</span></span><br><span class="line">    <span class="comment">//这条线上的区间变化后</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x:V[i])S.L=x.yl,S.R=x.yr,S.W=<span class="number">1</span>,S.<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,d);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x:V1[i])S.L=x.yl,S.R=x.yr,S.W=<span class="number">-1</span>,S.<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,d);</span><br><span class="line">		<span class="keyword">int</span> y=S.<span class="built_in">query1</span>(d);<span class="comment">//区间最小值不为0，则区间全被覆盖</span></span><br><span class="line">		<span class="keyword">if</span>(y!=<span class="number">-1</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;YES\n%d %d\n&quot;</span>,i,y);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)朴素并查集：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)维护size的并查集：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N], size[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)维护到祖宗节点距离的并查集：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>满足单调性的栈</p>
<p><strong><a href="https://www.luogu.com.cn/problem/P5788">模板题</a></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sd second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_INT 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// inline void print(__int128 x)&#123;if(x&lt;0)&#123;putchar(&#x27;-&#x27;);x=-x;&#125;if(x&gt;9) print(x/10);putchar(x%10+&#x27;0&#x27;);&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;<span class="keyword">if</span>(!b)&#123;x = <span class="number">1</span>; y = <span class="number">0</span>;<span class="keyword">return</span> a;&#125;<span class="keyword">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);y -= (a/b) * x;<span class="keyword">return</span> d;&#125;</span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll m, ll k, ll p)</span></span>&#123;ll res = <span class="number">1</span> % p, t = m;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;t = t * t % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,pos,idx;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i].v);a[i].idx = i;&#125;</span><br><span class="line">    stack&lt;node&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(a[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> now = a[i].v;</span><br><span class="line">        <span class="keyword">auto</span> t = s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">while</span>(now&gt;t.v)&#123;</span><br><span class="line">            a[t.idx].pos = i;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            t = s.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        cout &lt;&lt; a[i].pos &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="int128读写模板子"><a href="#int128读写模板子" class="headerlink" title="__int128读写模板子"></a>__int128读写模板子</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> __int128 <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __int128 x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">-1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>)</span><br><span class="line">        <span class="built_in">print</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> c)</span><span class="comment">//修改树状数组x位置的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tr[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//查询区间1~x的区间和；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i)) res+=tr[i];</span><br><span class="line">	<span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h1><h4 id="点权"><a href="#点权" class="headerlink" title="点权"></a>点权</h4><p>基于点权，查询单点值，修改路径的上的点权(HDU 3966 树链剖分 + 树状数组)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50010</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next; </span><br><span class="line">&#125;edge[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],tot;</span><br><span class="line"><span class="keyword">int</span> top[MAXN];<span class="comment">//top[v] 表示 v 所在的重链的顶端节点 int fa[MAXN];//父亲节点</span></span><br><span class="line"><span class="keyword">int</span> deep[MAXN];<span class="comment">//深度</span></span><br><span class="line"><span class="keyword">int</span> num[MAXN];<span class="comment">//num[v] 表示以 v 为根的子树的节点数 int p[MAXN];//p[v] 表示 v 对应的位置</span></span><br><span class="line"><span class="keyword">int</span> fp[MAXN];<span class="comment">//fp 和 p 数组相反</span></span><br><span class="line"><span class="keyword">int</span> son[MAXN];<span class="comment">//重儿子</span></span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tot = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">memset</span>(head,−<span class="number">1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">	pos = <span class="number">1</span>;<span class="comment">//使用树状数组，编号从头 1 开始 </span></span><br><span class="line">    <span class="built_in">memset</span>(son,−<span class="number">1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(son));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[tot].to = v; edge[tot].next = head[u]; head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> d)</span></span>&#123; </span><br><span class="line">    deep[u] = d;</span><br><span class="line">    fa[u] = pre;</span><br><span class="line">    num[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i != −<span class="number">1</span>; i = edge[i].next)&#123; </span><br><span class="line">        <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v != pre)&#123;</span><br><span class="line">			<span class="built_in">dfs1</span>(v,u,d+<span class="number">1</span>);</span><br><span class="line">            num[u] += num[v];</span><br><span class="line">			<span class="keyword">if</span>(son[u] == −<span class="number">1</span> || num[v] &gt; num[son[u]])</span><br><span class="line">				son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpos</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> sp)</span></span>&#123;</span><br><span class="line">    top[u] = sp;</span><br><span class="line">    p[u] = pos++;</span><br><span class="line">    fp[p[u]] = u;</span><br><span class="line">    <span class="keyword">if</span>(son[u] == −<span class="number">1</span>) <span class="keyword">return</span>; </span><br><span class="line">    <span class="built_in">getpos</span>(son[u],sp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v != son[u] &amp;&amp; v != fa[u])&#123;</span><br><span class="line">            <span class="built_in">getpos</span>(v,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树状数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;(−x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> c[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		s += c[i];</span><br><span class="line">		i −= <span class="built_in">lowbit</span>(i); </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> s; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span>&#123; </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">		c[i] += val;</span><br><span class="line">        i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//u-&gt;v 的路径上点的值改变 val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f1 = top[u], f2 = top[v]; </span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(f1 != f2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(deep[f1] &lt; deep[f2])&#123; </span><br><span class="line">            <span class="built_in">swap</span>(f1,f2);</span><br><span class="line">			<span class="built_in">swap</span>(u,v); </span><br><span class="line">        &#125;</span><br><span class="line">		<span class="built_in">add</span>(p[f1],val); <span class="built_in">add</span>(p[u]+<span class="number">1</span>,−val); </span><br><span class="line">        u = fa[f1];</span><br><span class="line">		f1 = top[u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(deep[u] &gt; deep[v]) <span class="built_in">swap</span>(u,v); </span><br><span class="line">    <span class="built_in">add</span>(p[u],val); </span><br><span class="line">    <span class="built_in">add</span>(p[v]+<span class="number">1</span>,−val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> M,P;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;M,&amp;P) == <span class="number">3</span>)&#123; </span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">    	<span class="keyword">int</span> C1,C2,K;</span><br><span class="line">    	<span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">    	<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(M−−)&#123; </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v); </span><br><span class="line">            <span class="built_in">addedge</span>(u,v); </span><br><span class="line">            <span class="built_in">addedge</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">getpos</span>(<span class="number">1</span>,<span class="number">1</span>); </span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(c)); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="built_in">add</span>(p[i],a[i]);</span><br><span class="line">        	<span class="built_in">add</span>(p[i]+<span class="number">1</span>,−a[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(P−−)&#123; </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        	<span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)&#123; </span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sum</span>(p[u]));</span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;C1,&amp;C2,&amp;K); </span><br><span class="line">                <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                    K = −K; </span><br><span class="line">                    <span class="built_in">Change</span>(C1,C2,K);</span><br><span class="line">                &#125;</span><br><span class="line">        	&#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="边权"><a href="#边权" class="headerlink" title="边权"></a>边权</h4><p>基于边权，修改单条边权，查询路径边权最大值(SPOJ QTREE 树链剖分 + 线段树)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10010</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next; </span><br><span class="line">&#125;edge[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],tot;</span><br><span class="line"><span class="keyword">int</span> top[MAXN];<span class="comment">//top[v] 表示 v 所在的重链的顶端节点</span></span><br><span class="line"><span class="keyword">int</span> fa[MAXN]; <span class="comment">//父亲节点</span></span><br><span class="line"><span class="keyword">int</span> deep[MAXN];<span class="comment">//深度</span></span><br><span class="line"><span class="keyword">int</span> num[MAXN];<span class="comment">//num[v] 表示以 v 为根的子树的节点数</span></span><br><span class="line"><span class="keyword">int</span> p[MAXN];<span class="comment">//p[v] 表示 v 与其父亲节点的连边在线段树中的位置</span></span><br><span class="line"><span class="keyword">int</span> fp[MAXN];<span class="comment">//和 p 数组相反 </span></span><br><span class="line"><span class="keyword">int</span> son[MAXN];<span class="comment">//重儿子</span></span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tot = <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">memset</span>(head,−<span class="number">1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(head)); </span><br><span class="line">	pos = <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">memset</span>(son,−<span class="number">1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(son));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[tot].to = v;edge[tot].next = head[u];head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一遍 dfs 求出 fa,deep,num,son </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	deep[u] = d; </span><br><span class="line">	fa[u] = pre; </span><br><span class="line">	num[u] = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v != pre)&#123;</span><br><span class="line">			<span class="built_in">dfs1</span>(v,u,d+<span class="number">1</span>);</span><br><span class="line">            num[u] += num[v];</span><br><span class="line">            <span class="keyword">if</span>(son[u] == −<span class="number">1</span> || num[v] &gt; num[son[u]])</span><br><span class="line">            	son[u] = v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二遍 dfs 求出top和p</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpos</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> sp)</span></span>&#123;</span><br><span class="line">	top[u] = sp;</span><br><span class="line">	p[u] = pos++;</span><br><span class="line">	fp[p[u]] = u;</span><br><span class="line">	<span class="keyword">if</span>(son[u] == −<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">getpos</span>(son[u],sp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; i != −<span class="number">1</span>; i = edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v != son[u] &amp;&amp; v != fa[u])</span><br><span class="line">            <span class="built_in">getpos</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线段树 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">	<span class="keyword">int</span> Max;</span><br><span class="line">&#125;segTree[MAXN*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	segTree[i].l = l; segTree[i].r = r; </span><br><span class="line">	segTree[i].Max = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>; </span><br><span class="line">	<span class="built_in">build</span>(i&lt;&lt;<span class="number">1</span>,l,mid); <span class="built_in">build</span>((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    segTree[i].Max = <span class="built_in">max</span>(segTree[i&lt;&lt;<span class="number">1</span>].Max,segTree[(i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>].Max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新线段树的第 k 个值为 val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(segTree[i].l == k &amp;&amp; segTree[i].r == k)&#123; </span><br><span class="line">		segTree[i].Max = val;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (segTree[i].l + segTree[i].r)/<span class="number">2</span>; </span><br><span class="line">	<span class="keyword">if</span>(k &lt;= mid)<span class="built_in">update</span>(i&lt;&lt;<span class="number">1</span>,k,val);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">update</span>((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,k,val);</span><br><span class="line">	<span class="built_in">push_up</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询线段树中 [l,r] 的最大值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(segTree[i].l == l &amp;&amp; segTree[i].r == r) </span><br><span class="line">    	<span class="keyword">return</span> segTree[i].Max;</span><br><span class="line">    <span class="keyword">int</span> mid = (segTree[i].l + segTree[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(i&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(i&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">query</span>((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,mid+<span class="number">1</span>,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询 u-&gt;v 边的最大值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f1 = top[u], f2 = top[v]; </span><br><span class="line">	<span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f1 != f2)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(deep[f1] &lt; deep[f2])&#123; </span><br><span class="line">            <span class="built_in">swap</span>(f1,f2);</span><br><span class="line">            <span class="built_in">swap</span>(u,v); </span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="built_in">max</span>(tmp,<span class="built_in">query</span>(<span class="number">1</span>,p[f1],p[u]));</span><br><span class="line">    	u= fa[f1]; </span><br><span class="line">    	f1 = top[u]; </span><br><span class="line">   	&#125;</span><br><span class="line">   	<span class="keyword">if</span>(u == v) <span class="keyword">return</span> temp;</span><br><span class="line">   	<span class="keyword">if</span>(deep[u] &gt; deep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(tmp,<span class="built_in">query</span>(<span class="number">1</span>,p[son[u]],p[v]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e[MAXN][<span class="number">3</span>]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T); </span><br><span class="line">    <span class="keyword">while</span>(T−−)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n−<span class="number">1</span>;i++)&#123; </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;e[i][<span class="number">0</span>],&amp;e[i][<span class="number">1</span>],&amp;e[i][<span class="number">2</span>]); </span><br><span class="line">            <span class="built_in">addedge</span>(e[i][<span class="number">0</span>],e[i][<span class="number">1</span>]); </span><br><span class="line">            <span class="built_in">addedge</span>(e[i][<span class="number">1</span>],e[i][<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">getpos</span>(<span class="number">1</span>,<span class="number">1</span>); </span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,pos−<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n−<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(deep[e[i][<span class="number">0</span>]] &gt; deep[e[i][<span class="number">1</span>]]) </span><br><span class="line">                <span class="built_in">swap</span>(e[i][<span class="number">0</span>],e[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>,p[e[i][<span class="number">1</span>]],e[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">int</span> u,v; </span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op) == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>)<span class="keyword">break</span>; </span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v); </span><br><span class="line">			<span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find</span>(u,v));<span class="comment">//查询 u-&gt;v 路径上边权的最大值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">update</span>(<span class="number">1</span>,p[e[u−<span class="number">1</span>][<span class="number">1</span>]],v);<span class="comment">//修改第 u 条边的长度为 v</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Manacher-马拉车"><a href="#Manacher-马拉车" class="headerlink" title="Manacher(马拉车)"></a>Manacher(马拉车)</h1><p><strong>用处：</strong>求字符串所有的回文子串长度（最大值）</p>
<p>p[i]代表以i为中心的回文串长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    b[k ++ ] = <span class="string">&#x27;$&#x27;</span>, b[k ++ ] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) b[k ++ ] = a[i], b[k ++ ] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    b[k ++ ] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">    n = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mr = <span class="number">0</span>, mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mr) p[i] = <span class="built_in">min</span>(p[mid * <span class="number">2</span> - i], mr - i);</span><br><span class="line">        <span class="keyword">else</span> p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b[i - p[i]] == b[i + p[i]]) p[i] ++ ;</span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; mr)</span><br><span class="line">        &#123;</span><br><span class="line">            mr = i + p[i];</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">    n = <span class="built_in">strlen</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">manacher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res = <span class="built_in">max</span>(res, p[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>包含值域和指针域</p>
<h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的左边插入一个数x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l_insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = a, l[idx] = l[a];</span><br><span class="line">    r[r[a]] = idx, l[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h1><p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>筛法求欧拉函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_eulers</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>朴素求单个欧拉函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h1><p>线性筛</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//直接处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------ </span><br><span class="line"><span class="comment">//先筛出质数减少循环</span></span><br><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//输出格式 质因数 个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;<span class="comment">//质因子种类数  8只有1个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; primes[i] &lt;= x / primes[i]; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % primes[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % primes[i] == <span class="number">0</span>) x /= primes[i], s ++ ;</span><br><span class="line">            cout &lt;&lt; primes[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><h4 id="递归法-范围2000"><a href="#递归法-范围2000" class="headerlink" title="递归法    范围2000"></a>递归法    范围2000</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br></pre></td></tr></table></figure>
<h4 id="通过预处理逆元的方式求组合数-范围1e5"><a href="#通过预处理逆元的方式求组合数-范围1e5" class="headerlink" title="通过预处理逆元的方式求组合数        范围1e5"></a>通过预处理逆元的方式求组合数        范围1e5</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]</span><br><span class="line">如果取模的数是质数，可以用费马小定理求逆元</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span>    <span class="comment">// 快速幂模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;</span><br><span class="line">        a = (ll)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理阶乘的余数和阶乘逆元的余数</span></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    fact[i] = (ll)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (ll)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(n,m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fact[n]*infact[m]%mod*infact[n-m]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.acwing.com/media/article/image/2020/07/16/35805_f4228ae4c7-%E7%BB%84%E5%90%88%E6%95%B0.png" alt=""></p>
<h4 id="Lucas定理-范围1e18-，模数p范围1e5"><a href="#Lucas定理-范围1e18-，模数p范围1e5" class="headerlink" title="Lucas定理        范围1e18  ，模数p范围1e5"></a>Lucas定理        范围1e18  ，模数p范围1e5</h4><p>若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有：</p>
<p> C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span>  <span class="comment">// 快速幂模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;</span><br><span class="line">        a = (ll)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span>  <span class="comment">// 通过定理求组合数C(a, b)</span></span></span><br><span class="line"><span class="function"><span class="comment">//可以替换成上面预处理阶乘求组合数变成O(1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LL x = <span class="number">1</span>, y = <span class="number">1</span>;  <span class="comment">// x是分子，y是分母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; i --, j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        x = (ll)x * i % p;</span><br><span class="line">        y = (ll) y * j % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * (LL)<span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lucas</span><span class="params">(ll a, ll b, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">return</span> (ll)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="质因数分解求组合数-真实值"><a href="#质因数分解求组合数-真实值" class="headerlink" title="质因数分解求组合数    真实值"></a>质因数分解求组合数    真实值</h4><p>当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</p>
<ol>
<li>筛法求出范围内的所有质数</li>
<li>通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + …</li>
<li>用高精度乘法将所有质因子相乘</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N], cnt;     <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="keyword">int</span> sum[N];     <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];     <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span>      <span class="comment">// 线性筛法求素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span>       <span class="comment">// 求n！中的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> b)</span>       <span class="comment">// 高精度乘低精度模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_primes</span>(a);  <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 求每个质因数的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j ++ )</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h1><p><strong>主要作用：</strong>维护区间特定的顺序（中序遍历顺序不变）</p>
<p><strong>文艺伸展树</strong></p>
<p>区间翻转问题：这里编号可能会改变，但是维护的是另一个隐藏的顺序——此时区间从左往右的顺序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> s[<span class="number">2</span>];<span class="comment">//s[0]左儿子,s[1]右儿子</span></span><br><span class="line">  <span class="keyword">int</span> p, v;<span class="comment">//p父亲节点编号，v节点编号</span></span><br><span class="line">	<span class="keyword">int</span> size;<span class="comment">//当前节点为根的子树大小</span></span><br><span class="line">  <span class="keyword">int</span> flag;<span class="comment">//当前节点为根的子树是否反转</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _v, <span class="keyword">int</span> _p)</span></span>&#123;<span class="comment">//新节点初始化</span></span><br><span class="line">		v = _v, p = _p;</span><br><span class="line">		size = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="keyword">int</span> root, idx;<span class="comment">//根节点编号，节点个数（相当于内存池的指针）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//由子树更新当前节点信息（维护的信息一般是所有子节点的信息（最值，个数））</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tr[x].size = tr[tr[x].s[<span class="number">0</span>]].size + tr[tr[x].s[<span class="number">1</span>]].size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//更新子节点信息，一般在修改时用到，查询也用到（要传到叶子节点才能得到真实值）</span></span><br><span class="line">	<span class="keyword">if</span>(tr[x].flag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(tr[x].s[<span class="number">0</span>], tr[x].s[<span class="number">1</span>]);<span class="comment">//反转操作</span></span><br><span class="line">    <span class="comment">//下传</span></span><br><span class="line">		tr[tr[x].s[<span class="number">0</span>]].flag ^= <span class="number">1</span>;</span><br><span class="line">		tr[tr[x].s[<span class="number">1</span>]].flag ^= <span class="number">1</span>;</span><br><span class="line">		tr[x].flag = <span class="number">0</span>;<span class="comment">//清除标记</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//左旋右旋（合并了）</span></span><br><span class="line">	<span class="keyword">int</span> y = tr[x].p, z = tr[y].p;</span><br><span class="line">	<span class="keyword">int</span> k = tr[y].s[<span class="number">1</span>] == x;<span class="comment">//x是y的s[k]</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  口诀：（对于x）</span></span><br><span class="line"><span class="comment">  反儿子代替自己变成父亲正儿子</span></span><br><span class="line"><span class="comment">  父亲变成自己的反儿子</span></span><br><span class="line"><span class="comment">  代替父亲成为爷爷的（与原来相同）儿子</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//更新父子关系</span></span><br><span class="line">	tr[y].s[k] = tr[x].s[k^<span class="number">1</span>];</span><br><span class="line">	tr[tr[x].s[k^<span class="number">1</span>]].p = y;</span><br><span class="line">  </span><br><span class="line">	tr[x].s[k^<span class="number">1</span>] = y;</span><br><span class="line">	tr[y].p = x;</span><br><span class="line">  </span><br><span class="line">	tr[z].s[y==tr[z].s[<span class="number">1</span>]] = x;</span><br><span class="line">	tr[x].p = z;</span><br><span class="line">	<span class="built_in">pushup</span>(x),<span class="built_in">pushup</span>(y);<span class="comment">//父子关系改变，更新信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//把x不断左旋或右旋到k，并保持平衡</span></span><br><span class="line">  <span class="comment">//一般设置0，n+1为左右哨兵</span></span><br><span class="line">	<span class="keyword">while</span>(tr[x].p != k)&#123;<span class="comment">//没有到达</span></span><br><span class="line">		<span class="keyword">int</span> y = tr[x].p, z = tr[y].p;</span><br><span class="line">		<span class="keyword">if</span>(z!=k)&#123;<span class="comment">//爷爷如果就是k，只需要单旋</span></span><br><span class="line">			<span class="keyword">if</span>((tr[y].s[<span class="number">1</span>]==x) ^ (tr[z].s[<span class="number">1</span>]==y)) <span class="built_in">rotate</span>(x);<span class="comment">//直线型</span></span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">rotate</span>(y);<span class="comment">//之字型</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rotate</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!k) root = x;<span class="comment">//k==0说明此时x是根，更新root</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//biuld要递归，可以一个一个插入建立</span></span><br><span class="line">	<span class="keyword">int</span> u = root, p = <span class="number">0</span>;<span class="comment">//从根节点开始往下查找</span></span><br><span class="line">	<span class="keyword">while</span>(u) p = u, u = tr[u].s[v&gt;tr[u].v];<span class="comment">//v大在右子树</span></span><br><span class="line">	u = ++idx;<span class="comment">//新建节点的编号</span></span><br><span class="line">	<span class="keyword">if</span>(p) tr[p].s[v&gt;tr[p].v] = u;<span class="comment">//如果p不是哨兵，说明u不是根那它父亲节点是p</span></span><br><span class="line">	tr[u].<span class="built_in">init</span>(v,p);<span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">splay</span>(u,<span class="number">0</span>);<span class="comment">//把u伸展到根，保证平衡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//找到中序遍历第k个点</span></span><br><span class="line">	<span class="keyword">int</span> u = root;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">pushdown</span>(u);<span class="comment">//标记下传</span></span><br><span class="line">    <span class="comment">//由子树大小递归左儿子或右儿子</span></span><br><span class="line">		<span class="keyword">if</span>(tr[tr[u].s[<span class="number">0</span>]].size&gt;=k) u = tr[u].s[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[u].s[<span class="number">0</span>]].size+<span class="number">1</span>==k) <span class="keyword">return</span> u;</span><br><span class="line">		<span class="keyword">else</span> k-=tr[tr[u].s[<span class="number">0</span>]].size+<span class="number">1</span>,u = tr[u].s[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="built_in">pushdown</span>(u);</span><br><span class="line">	<span class="keyword">if</span>(tr[u].s[<span class="number">0</span>]) <span class="built_in">output</span>(tr[u].s[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span>(tr[u].v&gt;=<span class="number">1</span>&amp;&amp;tr[u].v&lt;=n) <span class="built_in">wtb</span>(tr[u].v);<span class="comment">//排除哨兵</span></span><br><span class="line">	<span class="keyword">if</span>(tr[u].s[<span class="number">1</span>]) <span class="built_in">output</span>(tr[u].s[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h1><h3 id="1-普通三分"><a href="#1-普通三分" class="headerlink" title="1. 普通三分"></a>1. 普通三分</h3><p>把区间三等分，需要两个点m1，m2，看哪个函数值更接近极值点，保留它更靠近的端点，另一个端点变成m1，m2其中的一个，如图</p>
<p><img src="https://pic2.zhimg.com/80/v2-4a6039459e5d9afc346ab74a3dab9e21_1440w.jpg" alt="1"></p>
<p>m2比m1更靠近极值点，所以r不变，l = m1</p>
<p><strong>不能处理存在函数值相等的单峰函数，必须严格单调</strong></p>
<p>多峰函数求极值用模拟退火</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> l = <span class="number">0</span>,r = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;=<span class="number">0.01</span>)&#123;<span class="comment">//精度问题</span></span><br><span class="line">    <span class="keyword">double</span> m1 = l + (r-l)/<span class="number">3.0</span>,m2 = r - (r-l)/<span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(m1)&lt;<span class="built_in">f</span>(m2))<span class="comment">//极大值</span></span><br><span class="line">        l = m1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r = m2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-三分套三分"><a href="#2-三分套三分" class="headerlink" title="2.三分套三分"></a>2.三分套三分</h3><p>三分套三分与三分类似，每个三分对应的都是一个变量，在三分第一个变量的时候，再三分第二个变量，与二分套二分类似。当然，每个变量与答案之间的关系是一个单峰函数，如果是单调的换成二分即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;=<span class="number">0.01</span>)&#123;<span class="comment">//三分y</span></span><br><span class="line">        <span class="keyword">double</span> m1 = l + (r-l)/<span class="number">3.0</span>,m2 = r - (r-l)/<span class="number">3.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">f</span>(m1)&lt;<span class="built_in">f</span>(m2))<span class="comment">//极大值</span></span><br><span class="line">            l = m1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = m2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;=<span class="number">0.01</span>)&#123;<span class="comment">//三分x</span></span><br><span class="line">    <span class="keyword">double</span> m1 = l + (r-l)/<span class="number">3.0</span>,m2 = r - (r-l)/<span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(m1)&lt;<span class="built_in">find</span>(m2))</span><br><span class="line">        l = m1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r = m2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h4 id="1-常用基础函数"><a href="#1-常用基础函数" class="headerlink" title="1.常用基础函数"></a>1.常用基础函数</h4><h5 id="符号函数"><a href="#符号函数" class="headerlink" title="符号函数"></a>符号函数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (x&lt;<span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="角度弧度转化"><a href="#角度弧度转化" class="headerlink" title="角度弧度转化"></a>角度弧度转化</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">R_to_D</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="comment">//弧度转角度</span></span><br><span class="line">	<span class="keyword">return</span> x * <span class="number">180</span> / PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">D_to_R</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="comment">//角度转弧度</span></span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">180</span> * PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="弧长计算"><a href="#弧长计算" class="headerlink" title="弧长计算"></a>弧长计算</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Arc_len</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> R)</span> </span>&#123; <span class="comment">//弧度算弧长</span></span><br><span class="line">	<span class="keyword">return</span> x * R; <span class="comment">//R是半径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Arc_len</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> R)</span> </span>&#123; <span class="comment">//角度算弧长</span></span><br><span class="line">	<span class="keyword">return</span> x / <span class="number">180</span> * PI * R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-常用的类"><a href="#2-常用的类" class="headerlink" title="2.常用的类"></a>2.常用的类</h4><h5 id="点类"><a href="#点类" class="headerlink" title="点类"></a>点类</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    <span class="built_in">Point</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">double</span> _x,<span class="keyword">double</span> _y)&#123;x = _x,y = _y;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;x,&amp;y);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%.2f %.2f\n&quot;</span>,x,y);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (Point b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x-b.x) == <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(y-b.y) == <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Point b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x-b.x) == <span class="number">0</span> ? <span class="built_in">sgn</span>(y-b.y)&lt;<span class="number">0</span> : x&lt;b.x;&#125;<span class="comment">//和PII的默认一样</span></span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x-b.x,y-b.y);&#125;</span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Point &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x+b.x,y+b.y);&#125;</span><br><span class="line">    Point <span class="keyword">operator</span> * (<span class="keyword">const</span> <span class="keyword">double</span> &amp;k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x*k,y*k);&#125; </span><br><span class="line">    Point <span class="keyword">operator</span> / (<span class="keyword">const</span> <span class="keyword">double</span> &amp;k)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x/k,y/k);&#125; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 叉积</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Point &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> x*b.y-y*b.x;&#125;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点积</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Point &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> x*b.x+y*b.y;&#125;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回到原点的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">len</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">hypot</span>(x,y);&#125;                                </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回长度平方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">len2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x*x+y*y;&#125;                                  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两点间距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(Point p)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">hypot</span>(x-p.x,y-p.y);&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算该点看a,b点的角度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">rad</span><span class="params">(Point a,Point b)</span></span>&#123;Point p = *<span class="keyword">this</span>;<span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">atan2</span>(<span class="built_in">fabs</span>((a-p)^(b-p)),(a-p)*(b-p)));&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 化为长度为r的向量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Point <span class="title">trunc</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">double</span> l = <span class="built_in">len</span>();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">sgn</span>(l)) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//原来长度为0</span></span><br><span class="line">        r /= l;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x*r,y*r);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逆时针转90度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Point <span class="title">rotleft</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(-y,x);&#125;                             </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顺时针转90度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Point <span class="title">rotright</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(y,-x);&#125;                            </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绕p点逆时针转angle</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Point <span class="title">rotate</span><span class="params">(Point p,<span class="keyword">double</span> angle)</span></span>&#123;                              </span><br><span class="line">        Point v = (*<span class="keyword">this</span>)-p;</span><br><span class="line">        <span class="keyword">double</span> c = <span class="built_in">cos</span>(angle),s = <span class="built_in">sin</span>(angle);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(p.x+v.x*c-v.y*s,p.y+v.x*s+v.y*c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="线类"><a href="#线类" class="headerlink" title="线类"></a>线类</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">    Point s,e;</span><br><span class="line">    <span class="built_in">Line</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Line</span>(Point _s,Point _e)&#123;s = _s;e = _e;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (Line v)&#123;<span class="built_in"><span class="keyword">return</span></span> (s == v.s) &amp;&amp; (e == v.e);&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据一个点和倾斜角angle确定直线，0&lt;=angle&lt;=pi</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">Line</span>(Point p,<span class="keyword">double</span> angle)&#123;                                     </span><br><span class="line">        s = p;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(angle-pi/<span class="number">2</span>) == <span class="number">0</span>)&#123;e = (s+<span class="built_in">Point</span>(<span class="number">0</span>,<span class="number">1</span>));&#125;<span class="comment">//特判垂直x轴</span></span><br><span class="line">        <span class="keyword">else</span>&#123;e = (s+<span class="built_in">Point</span>(<span class="number">1</span>,<span class="built_in">tan</span>(angle)));&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ax+by+c=0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">Line</span>(<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">double</span> c)&#123;                               </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(a) == <span class="number">0</span>)&#123;s = <span class="built_in">Point</span>(<span class="number">0</span>,-c/b);e=<span class="built_in">Point</span>(<span class="number">1</span>,-c/b);&#125;<span class="comment">//特判垂直x轴</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sgn</span>(b) == <span class="number">0</span>)&#123;s = <span class="built_in">Point</span>(-c/a,<span class="number">0</span>);e = <span class="built_in">Point</span>(-c/a,<span class="number">1</span>);&#125;<span class="comment">//特判垂直y轴</span></span><br><span class="line">        <span class="keyword">else</span>&#123;s = <span class="built_in">Point</span>(<span class="number">0</span>,-c/b);e = <span class="built_in">Point</span>(<span class="number">1</span>,(-c-a)/b);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;s.<span class="built_in">input</span>();e.<span class="built_in">input</span>();&#125;<span class="comment">//调用了点类的input                             </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(e &lt; s) <span class="built_in">swap</span>(s,e);&#125;<span class="comment">//起点总是在左下方</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求线段长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> s.<span class="built_in">distance</span>(e);&#125;                          </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回直线倾斜角0&lt;=angle&lt;=pi</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">angle</span><span class="params">()</span></span>&#123;                                                 </span><br><span class="line">        <span class="keyword">double</span> k = <span class="built_in">atan2</span>(e.y-s.y,e.x-s.x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(k)&lt;<span class="number">0</span>) k+=pi;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(k-pi)==<span class="number">0</span>) k-= pi;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点和直线的关系</span></span><br><span class="line"><span class="comment">     * 1在左侧</span></span><br><span class="line"><span class="comment">     * 2在右侧</span></span><br><span class="line"><span class="comment">     * 3在直线上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pointonseg</span><span class="params">(Point p)</span></span>&#123;                                          </span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">sgn</span>((p-s)^(e-s));</span><br><span class="line">        <span class="keyword">if</span>(c &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点在线段上的判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>  <span class="title">pointonseg</span><span class="params">(Point p)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>((p-s)^(e-s)) == <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>((p-s)*(e-s)) &lt;= <span class="number">0</span>;&#125;   </span><br><span class="line">    <span class="comment">/**	</span></span><br><span class="line"><span class="comment">     * 两向量平行（对应直线平行或重合）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">parallel</span><span class="params">(Line v)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>((e-s)^(v.e-v.s)) == <span class="number">0</span>;&#125;        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两线段相交判断</span></span><br><span class="line"><span class="comment">     * 2规范相交</span></span><br><span class="line"><span class="comment">     * 1非规范相交  </span></span><br><span class="line"><span class="comment">     * 0不相交</span></span><br><span class="line"><span class="comment">     * 相交有很多种，这里指的“相交”是指两条线段恰好有唯一一个不是端点的公共点，我们称为“规范相交”。即如果一条线段的一个端点恰在另一线段上，则不视为相交；如果两条线段部分重合，也不视为相交，（这些情况我们称为“非规范相交”）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">segcrosseg</span><span class="params">(Line v)</span></span>&#123;                                         </span><br><span class="line">        <span class="keyword">int</span> d1 = <span class="built_in">sgn</span>((e-s)^(v.s-s));</span><br><span class="line">        <span class="keyword">int</span> d2 = <span class="built_in">sgn</span>((e-s)^(v.e-s));</span><br><span class="line">        <span class="keyword">int</span> d3 = <span class="built_in">sgn</span>((v.e-v.s)^(s-v.s));</span><br><span class="line">        <span class="keyword">int</span> d4 = <span class="built_in">sgn</span>((v.e-v.s)^(e-v.s));</span><br><span class="line">        <span class="keyword">if</span>((d1^d2) == <span class="number">-2</span> &amp;&amp; (d3^d4) == <span class="number">-2</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (d1 == <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>((v.s-s)*(v.s-e)) &lt;= <span class="number">0</span>) || </span><br><span class="line">               (d2 == <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>((v.e-s)*(v.e-e)) &lt;= <span class="number">0</span>) ||</span><br><span class="line">               (d3 == <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>((s-v.s)*(s-v.e)) &lt;= <span class="number">0</span>) ||</span><br><span class="line">               (d4 == <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>((e-v.s)*(e-v.e)) &lt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直线和线段相交判断</span></span><br><span class="line"><span class="comment">     * 2规范相交</span></span><br><span class="line"><span class="comment">     * 1非规范相交</span></span><br><span class="line"><span class="comment">     * 0不相交</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">linecrossseg</span><span class="params">(Line v)</span></span>&#123;                                       </span><br><span class="line">        <span class="keyword">int</span> d1 = <span class="built_in">sgn</span>((e-s)^(v.s-s));</span><br><span class="line">        <span class="keyword">int</span> d2 = <span class="built_in">sgn</span>((e-s)^(v.e-s));</span><br><span class="line">        <span class="keyword">if</span>((d1^d2) == <span class="number">-2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (d1 == <span class="number">0</span> || d2 == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两直线关系</span></span><br><span class="line"><span class="comment">     * 0平行</span></span><br><span class="line"><span class="comment">     * 1重合</span></span><br><span class="line"><span class="comment">     * 2相交</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">linecrossline</span><span class="params">(Line v)</span></span>&#123;                                      </span><br><span class="line">        <span class="keyword">if</span>((*<span class="keyword">this</span>).<span class="built_in">parallel</span>(v)) <span class="keyword">return</span> v.<span class="built_in">pointonseg</span>(s) == <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求两直线焦点，要保证两直线不平行或重合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Point <span class="title">crosspoint</span><span class="params">(Line v)</span></span>&#123;                                       </span><br><span class="line">        <span class="keyword">double</span> a1 = (v.e-v.s)^(s-v.s);</span><br><span class="line">        <span class="keyword">double</span> a2 = (v.e-v.s)^(e-v.s);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点到直线的距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dispointtoline</span><span class="params">(Point p)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">fabs</span>((p-s)^(e-s))/<span class="built_in">length</span>();&#125;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点到线段的距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dispointtoseg</span><span class="params">(Point p)</span></span>&#123;                                  </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>((p-s)*(e-s)) &lt; <span class="number">0</span> || <span class="built_in">sgn</span>((p-e)*(s-e)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(p.<span class="built_in">distance</span>(s),p.<span class="built_in">distance</span>(e));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispointtoline</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线段到线段的距离，前提是两线段不相交，相交距离为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dissegtoseg</span><span class="params">(Line v)</span></span>&#123;                                     </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="built_in">dispointtoseg</span>(v.s),<span class="built_in">dispointtoseg</span>(v.e)),<span class="built_in">min</span>(v.<span class="built_in">dispointtoseg</span>(s),v.<span class="built_in">dispointtoseg</span>(e)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回点p在直线上的投影</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Point <span class="title">lineprog</span><span class="params">(Point p)</span></span>&#123;<span class="keyword">return</span> s+(((e-s)*((e-s)*(p-s)))/((e-s).<span class="built_in">len2</span>()));&#125;   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回点p关于直线的对称点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Point <span class="title">symmetypoint</span><span class="params">(Point p)</span></span>&#123;Point q = <span class="built_in">lineprog</span>(p);<span class="keyword">return</span> <span class="built_in">Point</span>(<span class="number">2</span>*q.x-p.x,<span class="number">2</span>*q.y-p.y);&#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="圆类"><a href="#圆类" class="headerlink" title="圆类"></a>圆类</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Point p;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    <span class="built_in">circle</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">circle</span>(Point _p,<span class="keyword">double</span> _r)&#123;p = _p;r = _r;&#125;</span><br><span class="line">    <span class="built_in">circle</span>(<span class="keyword">double</span> x,<span class="keyword">double</span> y,<span class="keyword">double</span> _r)&#123;p = <span class="built_in">Point</span>(x,y);r = _r;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 三角形外接圆，需要Point的+/rotate()以及line的crosspoint()。利用两边中垂线得圆心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">circle</span>(Point a,Point b,Point c)&#123;                                 </span><br><span class="line">        Line u = <span class="built_in">Line</span>((a+b)/<span class="number">2</span>,((a+b)/<span class="number">2</span>)+((b-a).<span class="built_in">rotleft</span>()));</span><br><span class="line">        Line v = <span class="built_in">Line</span>((b+c)/<span class="number">2</span>,((b+c)/<span class="number">2</span>)+((c-b).<span class="built_in">rotleft</span>()));</span><br><span class="line">        p = u.<span class="built_in">crosspoint</span>(v);</span><br><span class="line">        r = p.<span class="built_in">distance</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 三角形内切圆,参数bool t无作用，只是与外接圆区别  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">circle</span>(Point a,Point b,Point c,<span class="keyword">bool</span> t)&#123;                          </span><br><span class="line">        Line u,v;</span><br><span class="line">        <span class="keyword">double</span> m = <span class="built_in">atan2</span>(b.y-a.y,b.x-a.x),n = <span class="built_in">atan2</span>(c.y-a.y,c.x-a.x);</span><br><span class="line">        u.s = a,v.s = b;</span><br><span class="line">        u.e = u.s+<span class="built_in">Point</span>(<span class="built_in">cos</span>((n+m)/<span class="number">2</span>),<span class="built_in">sin</span>((n+m)/<span class="number">2</span>));</span><br><span class="line">        m = <span class="built_in">atan2</span>(a.y-b.y,a.x-b.x),n = <span class="built_in">atan2</span>(c.y-b.y,c.x-b.x);</span><br><span class="line">        v.e = v.s+<span class="built_in">Point</span>(<span class="built_in">cos</span>((n+m)/<span class="number">2</span>),<span class="built_in">sin</span>((n+m)/<span class="number">2</span>));</span><br><span class="line">        p = u.<span class="built_in">crosspoint</span>(v);</span><br><span class="line">        r = <span class="built_in">Line</span>(a,b).<span class="built_in">dispointtoseg</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;p.<span class="built_in">input</span>();<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;r);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%.2lf %.2lf %.2lf\n&quot;</span>,p.x,p.y,r);&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (circle v)<span class="keyword">const</span>&#123;<span class="built_in"><span class="keyword">return</span></span> (p==v.p) &amp;&amp; <span class="built_in">sgn</span>(r-v.r) == <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (circle v)<span class="keyword">const</span>&#123;<span class="keyword">return</span> ((p&lt;v.p) || ((p==v.p) &amp;&amp; <span class="built_in">sgn</span>(r-v.r) &lt; <span class="number">0</span>));&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回面积</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> pi*r*r;&#125;                                </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回周长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">circumference</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">2</span>*pi*r;&#125;                      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点和圆的关系，0圆外，1圆上，2圆内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">relation</span><span class="params">(Point b)</span></span>&#123;                                           </span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> dst = b.<span class="built_in">distance</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(dst-r) &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sgn</span>(dst-r) == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线段和圆的关系，比较的是圆心到线段的距离和半径的关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">relationseg</span><span class="params">(Line v)</span></span>&#123;                                          </span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> dst = v.<span class="built_in">dispointtoseg</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(dst-r) &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sgn</span>(dst-r) == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直线和圆的关系，比较的是圆心到线段的距离和半径的关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">relationline</span><span class="params">(Line v)</span></span>&#123;                                         </span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> dst = v.<span class="built_in">dispointtoline</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(dst-r) &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sgn</span>(dst-r) == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两圆关系</span></span><br><span class="line"><span class="comment">     * 5相离</span></span><br><span class="line"><span class="comment">     * 4外切</span></span><br><span class="line"><span class="comment">     * 3相交</span></span><br><span class="line"><span class="comment">     * 2内切</span></span><br><span class="line"><span class="comment">     * 1内含</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">relationcircle</span><span class="params">(circle v)</span></span>&#123;                                   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> d = p.<span class="built_in">distance</span>(v.p);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(d-r-v.r) &gt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(d-r-v.r) == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">double</span> l = <span class="built_in">fabs</span>(r-v.r);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(d-r-v.r)&lt;<span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(d-l)&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(d-l) == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(d-l) &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *求两圆交点</span></span><br><span class="line"><span class="comment">    *0是无交点</span></span><br><span class="line"><span class="comment">    *1是一个交点</span></span><br><span class="line"><span class="comment">    *2是两个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pointcrosscircle</span><span class="params">(circle v,Point &amp;p1,Point &amp;p2)</span></span>&#123;              </span><br><span class="line">        <span class="keyword">int</span> rel = <span class="built_in">relationcircle</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(rel == <span class="number">1</span> || rel == <span class="number">5</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> d = p.<span class="built_in">distance</span>(v.p);</span><br><span class="line">        <span class="keyword">double</span> l = (d*d+r*r-v.r*v.r)/(<span class="number">2</span>*d);</span><br><span class="line">        <span class="keyword">double</span> h = <span class="built_in">sqrt</span>(r*r-l*l);</span><br><span class="line">        Point tmp = p + (v.p-p).<span class="built_in">trunc</span>(l);</span><br><span class="line">        p1 = tmp + ((v.p-p).<span class="built_in">rotleft</span>().<span class="built_in">trunc</span>(h));</span><br><span class="line">        p2 = tmp + ((v.p-p).<span class="built_in">rotright</span>().<span class="built_in">trunc</span>(h));</span><br><span class="line">        <span class="keyword">if</span>(rel == <span class="number">2</span> || rel == <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>字符串匹配进阶</title>
    <url>/2021/11/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h3 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h3><p><strong>A位模式串，长度为n；B为文本串，长度为m。</strong></p>
<p> 1.没有通配符的</p>
<ul>
<li>首先引入一个匹配函数$C(x,y) = A(x) - B(y)$,当C(x,y) = 0，我们认为A的第x字符和B的第y个字符相等。</li>
<li>再将一个字符匹配扩展到一个字符串。</li>
<li>那么，完全匹配函数$P(x) =\displaystyle \sum^{m-1}_{i=0} C(i,x-m+i+1)$ ,若P(x) = 0，则B以x结尾的连续m位子串和A完全匹配。</li>
<li>上面的完全匹配函数存在一些错误<ul>
<li>把求和函数拆开会发现就是匹配的两个串的每个字符分别相加，然后；两个和相减。那么只要字符的类型，个数对应相同就被判定相同，忽略了每个字符的对应关系。</li>
<li>产生错误的原因是每个字符的匹配函数有正有负，求和可能相互抵消为0。</li>
<li>解决方法就是把匹配函数$C(x,y)$平方，因为若干个平方数相加=0只能是每一项都为0，和我们完全匹配时每个位置的$C(x,y)=0$时等价的。</li>
<li><strong>等价转化——</strong>  <strong>我们把A反转变成S，那么A(i) = S(m-i-1)。因为这样子匹配函数的x，y相加总是等于一个常数。（这很重要）</strong></li>
</ul>
</li>
<li>正确的完全匹配函数为$P(x) =\displaystyle \sum^{m-1}_{i=0} (S[m-i-1] - B[x-m+i+1])^2$</li>
<li>将函数暴力展开为$P(x) =\displaystyle \sum^{m-1}_{i=0} ({S[m-i-1]}^2 + {B[x-m+i+1]}^2 - 2  S[m-i-1]  B[x-m+i+1])$</li>
<li>再展开为三部分<ol>
<li>$\displaystyle \sum^{m-1}_{i=0} {S[m-i-1]}^2$  显然，这是个定值记作T，我们可以$O(m)$暴力预处理</li>
<li>$\displaystyle \sum^{m-1}_{i=0}{B[x-m+i+1]}^2$ 这是一个长度为m的区间和，我们通过预处理前缀和数组f ( x )，然后$O(1)$得到</li>
<li>$\displaystyle -2\sum^{m-1}_{i=0}S[m-i-1]  B[x-m+i+1]$ 通过上面我们把A用他的反转S替换后，我们发现(m-i-1)+(x-m+i+1) 恒等于x。那么公式为$\displaystyle -2\sum_{i+i=x}S[i]  B[j]$。<ul>
<li>另$\displaystyle g(x) = \sum_{i+i=x}S[i]  B[j]$ ，显然这是个多项式乘法，可以通过FFT求出所有值</li>
</ul>
</li>
</ol>
</li>
<li>$P(x) = T + f(x) -  f(x-m) -2g(x)$ ，每个函数都可以通过上述求出，再$O(n)$求出所有P(x)</li>
</ul>
<ol>
<li><h5 id="有通配符的"><a href="#有通配符的" class="headerlink" title="有通配符的"></a>有通配符的</h5></li>
</ol>
<ul>
<li><p>调整匹配函数——和上述没有通配符的相同，但是我们要去掉通配符位置的贡献。</p>
</li>
<li><p><strong>将原字符串是通配符的值设为0，再修改完全匹配匹配函数为$P(x) =\displaystyle \sum^{m-1}_{i=0} (S[m-i-1] - B[x-m+i+1])^2S[m-i-1]B[x-m+i+1]$</strong></p>
<p><strong>其中一个为通配符就会乘上0，最后贡献为0</strong></p>
</li>
<li><p><strong>暴力展开-&gt;</strong>$P(x) =\displaystyle \sum^{m-1}_{i=0} ({S[m-i-1]}^3B[x-m+i+1] + {B[x-m+i+1]}^3S[m-i-1] - 2  (S[m-i-1]  B[x-m+i+1])^2)$</p>
<p>即$P(x) =\displaystyle \sum_{i+j=x} {S[i]}^3B[j] + \sum_{i+j=x}{B[j]}^3S[i] - 2  \sum_{i+j=x}(S[i]  B[j])^2$</p>
</li>
<li><p>6次FFT即可求的,再一次逆FFT回去即可</p>
</li>
</ul>
<h4 id="FFT板子"><a href="#FFT板子" class="headerlink" title="FFT板子"></a><strong>FFT板子</strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>- (<span class="keyword">const</span> Complex&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>* (<span class="keyword">const</span> Complex&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * t.x - y * t.y, x * t.y + y * t.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N], b[N];<span class="comment">//原来的多项式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rev[N], bit, tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex a[], <span class="keyword">int</span> inv)</span><span class="comment">//1:系数表示法-&gt;点表示法；-1:点表示法-&gt;系数表示法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])<span class="comment">//否则就会交换两次换回原来</span></span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> w1 = <span class="built_in">Complex</span>(&#123;<span class="built_in">cos</span>(PI / mid), inv * <span class="built_in">sin</span>(PI / mid)&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += mid * <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> wk = <span class="built_in">Complex</span>(&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j ++, wk = wk * w1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = a[i + j], y = wk * a[i + j + mid];</span><br><span class="line">                a[i + j] = x + y, a[i + j + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(inv==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) a[i].x/=tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="FFT匹配板子（带通配符）"><a href="#FFT匹配板子（带通配符）" class="headerlink" title="FFT匹配板子（带通配符）"></a><strong>FFT匹配板子（带通配符）</strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rev[maxn], tot, bit;</span><br><span class="line"><span class="keyword">double</span> a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT_MATCH</span><span class="params">(string s1, string s2, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//s1模式串（短），s2文本串（长）</span></span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(s1));</span><br><span class="line">    <span class="comment">//应避免某个字符的值为0，选取字符集中不存在的字符减去即可</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m) a[i] = s1[i]!=<span class="string">&#x27;*&#x27;</span> ? (s1[i]-<span class="string">&#x27;a&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n) b[i] = s2[i]!=<span class="string">&#x27;*&#x27;</span> ? (s2[i]-<span class="string">&#x27;a&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit) &lt; n+m+<span class="number">1</span>) bit++;</span><br><span class="line">	tot = <span class="number">1</span>&lt;&lt; bit; </span><br><span class="line">	<span class="comment">// debug(tot);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i ++ )</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) A[i].x = a[i]*a[i];</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) B[i].x = b[i]*b[i];</span><br><span class="line">    <span class="built_in">FFT</span>(A,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(B,<span class="number">1</span>);</span><br><span class="line">    Complex t;</span><br><span class="line">    t.x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) P[i] = P[i]-A[i]*B[i]*t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环到tot-1是因为上面卷积后会有系数大于n，m的项（上面第一次可以知道n，m）</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) A[i].x = a[i]*a[i]*a[i],A[i].y=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) B[i].x = b[i],B[i].y=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FFT</span>(A,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(B,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) P[i] = P[i]+A[i]*B[i];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) A[i].x = a[i],A[i].y=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) B[i].x = b[i]*b[i]*b[i],B[i].y=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FFT</span>(A,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(B,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) P[i] = P[i]+A[i]*B[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">FFT</span>(P,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,m,n)&#123; </span><br><span class="line">    	<span class="keyword">if</span>(<span class="built_in">fabs</span>(P[i].x) &lt;= <span class="number">1e-7</span>)&#123;</span><br><span class="line">    		cout &lt;&lt; i-m &lt;&lt;endl;<span class="comment">//匹配到的开始位置，i是结束位置</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n,m;<span class="comment">//字符串长度</span></span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		n--,m--;<span class="comment">//最高位指数</span></span><br><span class="line">		string s1,s2;</span><br><span class="line">		cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">		<span class="built_in">FFT_MATCH</span>(s2,s1,m,n);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h4 id="FFT匹配板子（不带通配符）"><a href="#FFT匹配板子（不带通配符）" class="headerlink" title="FFT匹配板子（不带通配符）"></a><strong>FFT匹配板子（不带通配符）</strong></h4><p>理论上带通配符版本可以处理没有通配符的</p>
<p>但是由于进行了6次FFT，常数更大，普通版只需要2次。</p>
<p>但是不带通配符的问题就是字符串匹配的模版题，KMP有更好的线性复杂度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>  sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT_MATCH</span><span class="params">(string s1, string s2, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//s1模式串（短），s2文本串（长）</span></span><br><span class="line">    <span class="built_in">reverse</span>(<span class="built_in">all</span>(s1));</span><br><span class="line">    <span class="comment">//应避免某个字符的值为0，选取字符集中不存在的字符减去即可</span></span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m) A[i].x = s1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,n) B[i].x = s2[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一部分</span></span><br><span class="line">    <span class="keyword">double</span> T = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,m) T+=A[i].x*A[i].x;<span class="comment">//计算定值T</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; T &lt;&lt;endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二部分</span></span><br><span class="line">    sum[<span class="number">0</span>] = B[<span class="number">0</span>].x*B[<span class="number">0</span>].x;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,n) </span><br><span class="line">    	sum[i] = sum[i<span class="number">-1</span>] + B[i].x*B[i].x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三部分</span></span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit) &lt; n+m+<span class="number">1</span>) bit++;</span><br><span class="line">	tot = <span class="number">1</span>&lt;&lt; bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i ++ )</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">FFT</span>(A,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(B,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) C[i] = A[i]*B[i];</span><br><span class="line">    <span class="built_in">FFT</span>(C,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i,m,n)&#123; </span><br><span class="line">        <span class="keyword">double</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==m) temp = T + sum[i] - <span class="number">2</span>*C[i].x;</span><br><span class="line">        <span class="keyword">else</span> temp = T + sum[i] - sum[i-m<span class="number">-1</span>] <span class="number">-2</span>*C[i].x;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span>(<span class="built_in">fabs</span>(temp) &lt;= <span class="number">1e-7</span>)&#123;</span><br><span class="line">    		cout &lt;&lt; i-m &lt;&lt;endl;<span class="comment">//匹配到的开始位置，i是结束位置</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="keyword">int</span> n,m;<span class="comment">//字符串长度</span></span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		n--,m--;<span class="comment">//最高位指数</span></span><br><span class="line">		string s1,s2;</span><br><span class="line">		cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">		<span class="built_in">FFT_MATCH</span>(s2,s1,m,n);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h4 id="FFT模糊匹配（k失配匹配）"><a href="#FFT模糊匹配（k失配匹配）" class="headerlink" title="FFT模糊匹配（k失配匹配）"></a>FFT模糊匹配（k失配匹配）</h4><p>一般这种问题能用FFT解决通常满足字符集较小</p>
<ul>
<li><p>枚举字符集中每种字符c[k]</p>
</li>
<li><p>构建两个复数数组</p>
<p>A[i].x = (s1[i]==c[k])——B[i].x = (s2[i]\==c[k])</p>
</li>
<li><p>对这两个数组进行无通配符的匹配</p>
</li>
<li><p>当且仅当对应位置相等并等于c[k]会有贡献1</p>
</li>
<li><p>对于字符集每个字符进行如上操作，将贡献累加到对应位置d[i]中</p>
</li>
<li><p>d[i]代表了以i结尾的位置匹配个数为d[i]个</p>
</li>
<li><p>d[i]&gt;=匹配串长度-可失配个数则——&gt;当前位置匹配成功</p>
</li>
</ul>
<hr>
<p><a href="https://www.luogu.com.cn/problem/P3763">P3763 [TJOI2017]DNA</a> FFT</p>
<p><strong>题意：</strong>在S中匹配P的个数（允许3处不一样）</p>
<p><strong>模板题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="comment">// #define PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	iocin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,x);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rev[maxn], tot, bit;</span><br><span class="line"><span class="keyword">double</span> a[maxn], b[maxn];</span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>- (<span class="keyword">const</span> Complex&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>* (<span class="keyword">const</span> Complex&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * t.x - y * t.y, x * t.y + y * t.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;A[maxn], B[maxn], C[maxn];<span class="comment">//原来的多项式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex aa[], <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            <span class="built_in">swap</span>(aa[i], aa[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> w1 = <span class="built_in">Complex</span>(&#123;<span class="built_in">cos</span>(PI / mid), inv * <span class="built_in">sin</span>(PI / mid)&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += mid * <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> wk = <span class="built_in">Complex</span>(&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j ++, wk = wk * w1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = aa[i + j], y = wk * aa[i + j + mid];</span><br><span class="line">                aa[i + j] = x + y, aa[i + j + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(inv==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) aa[i].x/=tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> cc[<span class="number">4</span>]=&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">mem</span>(d,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">int</span> n,m;<span class="comment">//字符串长度</span></span><br><span class="line">		string s1,s2;</span><br><span class="line">		cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">		m = s2.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">		n = s1.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">reverse</span>(<span class="built_in">all</span>(s2));</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;n+m+<span class="number">1</span>) bit++;</span><br><span class="line">		tot = <span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i ++ )</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="built_in">mem</span>(A,<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">mem</span>(B,<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,n) A[j].x = (s1[j]==cc[i])? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,m) B[j].x = (s2[j]==cc[i])? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">FFT</span>(A,<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">FFT</span>(B,<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,tot<span class="number">-1</span>) A[j] = A[j]*B[j];</span><br><span class="line">			<span class="built_in">FFT</span>(A,<span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">rep</span>(j,m,n) d[j] += (<span class="keyword">int</span>)(A[j].x+<span class="number">0.5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,m,n)&#123;</span><br><span class="line">			<span class="keyword">if</span>(d[i]&gt;=m<span class="number">-2</span>) ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">wtl</span>(ans);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://acm.dingbacode.com/showproblem.php?pid=6975">2021杭电多校第三场1003</a></p>
<p><strong>思路：</strong>和基因序列类似，不过加入了通配符。对于通配符的贡献我们要拿出来单独计算。由于文本串和模式串都包含通配符，需要用到一些小小的容斥原理。</p>
<ul>
<li>数字部分贡献和上题相同。</li>
<li>通配符贡献 = A中通配符贡献  +  B中通配符贡献  -  AB中同时是通配符贡献</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************</span></span><br><span class="line"><span class="comment">| Author:  pigstar</span></span><br><span class="line"><span class="comment">| Problem: Forgiving Matching</span></span><br><span class="line"><span class="comment">| Contest: HDOJ</span></span><br><span class="line"><span class="comment">| URL:     https://acm.dingbacode.com/showproblem.php?pid=6975</span></span><br><span class="line"><span class="comment">| When:    2021-10-16 00:46:51</span></span><br><span class="line"><span class="comment">| </span></span><br><span class="line"><span class="comment">| Memory:  524 MB</span></span><br><span class="line"><span class="comment">| Time:    12000 ms</span></span><br><span class="line"><span class="comment">*******************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	iocin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,x);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rev[maxn], tot, bit;</span><br><span class="line"><span class="keyword">double</span> a[maxn], b[maxn];</span><br><span class="line"><span class="comment">//复数类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> _r=<span class="number">0</span>,<span class="keyword">double</span> _i=<span class="number">0</span>)&#123;x=_r,y=_i;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>- (<span class="keyword">const</span> Complex&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>* (<span class="keyword">const</span> Complex&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x * t.x - y * t.y, x * t.y + y * t.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;A[maxn], B[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex aa[], <span class="keyword">int</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            <span class="built_in">swap</span>(aa[i], aa[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> w1 = <span class="built_in">Complex</span>(&#123;<span class="built_in">cos</span>(PI / mid), inv * <span class="built_in">sin</span>(PI / mid)&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i += mid * <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> wk = <span class="built_in">Complex</span>(&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; j ++, wk = wk * w1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = aa[i + j], y = wk * aa[i + j + mid];</span><br><span class="line">                aa[i + j] = x + y, aa[i + j + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(inv==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">0</span>,tot<span class="number">-1</span>) aa[i].x/=tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn];<span class="comment">//贡献--匹配了的个数</span></span><br><span class="line"><span class="keyword">int</span> ans[maxn];<span class="comment">//失配i匹配成功的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> n,m;<span class="comment">//字符串长度</span></span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		string s1,s2;</span><br><span class="line">		cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">		<span class="built_in">mem</span>(d,<span class="number">0</span>);<span class="built_in">mem</span>(ans,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">reverse</span>(<span class="built_in">all</span>(s2));</span><br><span class="line">		<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;bit)&lt;n+m<span class="number">-1</span>) bit++;</span><br><span class="line">		tot = <span class="number">1</span>&lt;&lt;bit;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i ++ )</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//只计算数字的匹配个数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">char</span> i = <span class="string">&#x27;0&#x27;</span>; i &lt;= <span class="string">&#x27;9&#x27;</span>; i++)&#123;</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,tot)&#123;</span><br><span class="line">				A[j].x = A[j].y = B[j].x = B[j].y = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) A[j].x = (s1[j]==i);</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,m<span class="number">-1</span>) B[j].x = (s2[j]==i);</span><br><span class="line">			<span class="built_in">FFT</span>(A,<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">FFT</span>(B,<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">0</span>,tot<span class="number">-1</span>) A[j] = A[j]*B[j];</span><br><span class="line">			<span class="built_in">FFT</span>(A,<span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">rep</span>(j,m<span class="number">-1</span>,n<span class="number">-1</span>)&#123; </span><br><span class="line">				d[j] += (<span class="keyword">int</span>)(A[j].x+<span class="number">0.5</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="comment">//S1中星号去匹配S2</span></span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,tot)&#123;</span><br><span class="line">			A[j].x = A[j].y = B[j].x = B[j].y = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,m<span class="number">-1</span>) B[j].x = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) A[j].x = (s1[j]==<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">		<span class="built_in">FFT</span>(A,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">FFT</span>(B,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,tot<span class="number">-1</span>) A[j] = A[j]*B[j];</span><br><span class="line">		<span class="built_in">FFT</span>(A,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,m<span class="number">-1</span>,n<span class="number">-1</span>) d[j] += (<span class="keyword">int</span>)(A[j].x+<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//S2星号去匹配S1</span></span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,tot)&#123;</span><br><span class="line">			A[j].x = A[j].y = B[j].x = B[j].y = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) A[j].x = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,m<span class="number">-1</span>) B[j].x = (s2[j]==<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">		<span class="built_in">FFT</span>(A,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">FFT</span>(B,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,tot<span class="number">-1</span>) A[j] = A[j]*B[j];</span><br><span class="line">		<span class="built_in">FFT</span>(A,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,m<span class="number">-1</span>,n<span class="number">-1</span>) d[j] += (<span class="keyword">int</span>)(A[j].x+<span class="number">0.5</span>);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="comment">//减去S1，S2同时是星号的匹配情况</span></span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,tot)&#123;</span><br><span class="line">			A[j].x = A[j].y = B[j].x = B[j].y = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) A[j].x = (s1[j]==<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,m<span class="number">-1</span>) B[j].x = (s2[j]==<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">		<span class="built_in">FFT</span>(A,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">FFT</span>(B,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,tot<span class="number">-1</span>) A[j] = A[j]*B[j];</span><br><span class="line">		<span class="built_in">FFT</span>(A,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">rep</span>(j,m<span class="number">-1</span>,n<span class="number">-1</span>) d[j] -= (<span class="keyword">int</span>)(A[j].x+<span class="number">0.5</span>);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="comment">//有成功匹配个数转化为失配个数</span></span><br><span class="line">		<span class="built_in">rep</span>(i,m<span class="number">-1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">			ans[m-d[i]]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出前缀和</span></span><br><span class="line">		ll now = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">			now+=ans[i];</span><br><span class="line">			<span class="built_in">wtl</span>(now);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h4 id="哈希k失配匹配问题"><a href="#哈希k失配匹配问题" class="headerlink" title="哈希k失配匹配问题"></a>哈希k失配匹配问题</h4><h5 id="P3763-TJOI2017-DNA-Hash-二分"><a href="#P3763-TJOI2017-DNA-Hash-二分" class="headerlink" title="P3763 [TJOI2017]DNA        Hash + 二分"></a><strong><a href="https://www.luogu.com.cn/problem/P3763">P3763 [TJOI2017]DNA</a>        Hash + 二分</strong></h5><p><strong>题意：</strong>在S中匹配P的个数（允许3处不一样）</p>
<p><strong>思路：</strong>枚举P (len=n) 在S (len = m) 的起点（$O(n)$）每一次都二分从当前起点开始下一处不匹配的地方在哪（$O(k \times log_{2}m$）（hs1[l…mid] != hs2[l….mid] 说明不匹配的点在前面—-&gt;r = mid-1否则l = mid+1）</p>
<p><strong>总复杂度：</strong>$O(nklog_{2}m)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	iocin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,x);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"></span><br><span class="line">ull hs[maxn][<span class="number">2</span>],P[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span></span>&#123;<span class="comment">//求字串哈希值</span></span><br><span class="line">    <span class="keyword">return</span> hs[r][id] - hs[l<span class="number">-1</span>][id] * P[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> l2)</span></span>&#123;<span class="comment">//l1 S开始位置；l2 P开始位置</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = M - l2+<span class="number">1</span>;<span class="comment">//二分的是往后相同的长度，最多到M，所以r是M-l2+1</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cal</span>(l1,l1+mid<span class="number">-1</span>,<span class="number">0</span>) == <span class="built_in">cal</span>(l2,l2+mid<span class="number">-1</span>,<span class="number">1</span>)) l = mid+<span class="number">1</span>;<span class="comment">//mid可行</span></span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        string S[<span class="number">2</span>];</span><br><span class="line">        cin &gt;&gt; S[<span class="number">0</span>] &gt;&gt; S[<span class="number">1</span>];</span><br><span class="line">        S[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span> + S[<span class="number">0</span>];</span><br><span class="line">        S[<span class="number">1</span>] = <span class="string">&#x27; &#x27;</span> + S[<span class="number">1</span>];</span><br><span class="line">        N = S[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>, M = S[<span class="number">1</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        P[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,N) P[i] = P[i<span class="number">-1</span>]*<span class="number">2333</span>;</span><br><span class="line">        <span class="comment">//计算字符串的哈希值前缀</span></span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,N) </span><br><span class="line">            hs[i][<span class="number">0</span>] = hs[i<span class="number">-1</span>][<span class="number">0</span>]*<span class="number">2333</span> + S[<span class="number">0</span>][i];</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,M) </span><br><span class="line">            hs[i][<span class="number">1</span>] = hs[i<span class="number">-1</span>][<span class="number">1</span>]*<span class="number">2333</span> + S[<span class="number">1</span>][i];</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+M<span class="number">-1</span>&gt;N) <span class="keyword">break</span>;<span class="comment">//从i开始往后长度不满足M</span></span><br><span class="line">            <span class="keyword">int</span> p1 = <span class="number">1</span>, p2 = <span class="number">1</span>;<span class="comment">//开始位置都是1</span></span><br><span class="line">            <span class="built_in">rep</span>(j,<span class="number">1</span>,<span class="number">4</span>)&#123;<span class="comment">//允许3次不同，那么找到第四个不同的点</span></span><br><span class="line">                <span class="keyword">int</span> x = <span class="built_in">lcp</span>(i+p1<span class="number">-1</span>,p2);<span class="comment">//相同的长度</span></span><br><span class="line">                <span class="comment">//更新位置</span></span><br><span class="line">                p1+=x;</span><br><span class="line">                p2+=x;</span><br><span class="line">                <span class="keyword">if</span>(j!=<span class="number">4</span>) p1++,p2++;<span class="comment">//跳过错误的位置，最后一个不能跳</span></span><br><span class="line">                <span class="keyword">if</span>(p2&gt;M)&#123;<span class="comment">//满足了</span></span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">wtl</span>(ans);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
]]></content>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/2021/11/17/%E6%95%B0%E4%BD%8DDP/</url>
    <content><![CDATA[<h1 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h1><h3 id="【介绍】"><a href="#【介绍】" class="headerlink" title="【介绍】"></a>【介绍】</h3><p>显然，是一种DP。</p>
<p>再显然，是一种关于每一位数字之间关系（性质）的DP</p>
<hr>
<h3 id="【题目特征】"><a href="#【题目特征】" class="headerlink" title="【题目特征】"></a>【题目特征】</h3><p><strong>题目描述</strong>一般是求【L，R】范围内满足各位数字间存在某种规律的数有几个</p>
<p>数位DP的题目<strong>数据范围</strong>往往很大，动不动就是1e18，但是由于是数位DP只跟位数有关，所以也就18位。</p>
<hr>
<h3 id="【算法设计】"><a href="#【算法设计】" class="headerlink" title="【算法设计】"></a>【算法设计】</h3><p>使用<strong>记忆化搜索</strong>进行DP因为会出现重复出现的状态，使用记忆化搜索可以减少重复的搜索，减少复杂度。</p>
<h4 id="一-记忆化搜索的过程"><a href="#一-记忆化搜索的过程" class="headerlink" title="一.记忆化搜索的过程"></a>一.记忆化搜索的过程</h4><p>​        从起点向下搜索，搜索的途中累加每一位的答案，最后在起点得到答案。</p>
<h4 id="二-区间转化为-0-X"><a href="#二-区间转化为-0-X" class="headerlink" title="二. 区间转化为[0,X]"></a>二. 区间转化为[0,X]</h4><p>​    对于[L,R]的区间问题，一般我们可以根据前缀和相减转化为[0,R] - [0,L-1]的问题。</p>
<h4 id="三-dfs的参数"><a href="#三-dfs的参数" class="headerlink" title="三.dfs的参数"></a>三.dfs的参数</h4><p><strong>pos</strong>, 当前找到了第几位<br><strong>limit</strong>，因为问题已经转化为了小于X的所有正整数中符合条件的个数，我们从高位枚举，一旦当前位小于X，那么后面数字可以随便选。limit就是判断当前位是否可以任意选。</p>
<blockquote>
<p><strong>递归中limit的传递</strong></p>
<p>1.当前没有限制limit=0，那么显然后面应该都没限制，是0</p>
<p>2.当前有限制limit=1；</p>
<p>​    1.如果当前位选的数小于X对应位数字，那么后面应该是没限制0</p>
<p>​    2.如果当前位选的数恰好等于X对应位数字，这个分支相当于是紧贴着X的每一位（前面枚举到的位选的和X一样），那么后面还要限制数字大小，limit为1</p>
<p><strong>综上：我们可以总结出limit的转移方程  limit = limit&amp;&amp;j==X[i]</strong> (X[i]是当前位能枚举得最大值, j是当前正在枚举得数)</p>
</blockquote>
<p>  3.<strong>pre，</strong>有些题目的性质是和前几位数字有关，那么也可以加上pre1…pre2</p>
<p>  4.<strong>zero，</strong>判断是否有前导0，比如所有位相同的数包括000333（实质是333）前面都是0的话取1，否则取0</p>
<blockquote>
<p><strong>递归中zero前导零的传递</strong></p>
<p>1.前一位是前导0</p>
<p>​    1.当前位是0，那么后面还是zero还是1</p>
<p>​    2.当前位不是0，那么后面zero=0</p>
<p>2.前一位不是前导0，那么不管当前位是不是0，后面zero都是1</p>
<p><strong>综上：我们可以总结出zero的转移方程  zero = zero&amp;&amp;(!j)</strong> (X[i]是当前位能枚举得最大值, j是当前正在枚举得数)</p>
</blockquote>
<h4 id="四-记忆化搜索的记忆化"><a href="#四-记忆化搜索的记忆化" class="headerlink" title="四.记忆化搜索的记忆化"></a>四.记忆化搜索的记忆化</h4><p>​    我们可以用一个dp数组来记录已经确认的状态的值，下标用来表示状态，等到后面搜到相同状态时不用递归到最底层直接可以拿来复用。</p>
<h4 id="五-模板"><a href="#五-模板" class="headerlink" title="五.模板"></a>五.模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> pre,<span class="keyword">int</span> st,……,<span class="keyword">int</span> lead,<span class="keyword">int</span> limit)</span><span class="comment">//记忆化搜索</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;len) <span class="keyword">return</span> st;<span class="comment">//剪枝</span></span><br><span class="line">    <span class="keyword">if</span>((dp[pos][pre][st]……[……]!=<span class="number">-1</span>&amp;&amp;(!limit)&amp;&amp;(!lead))) <span class="keyword">return</span> dp[pos][pre][st]……[……];<span class="comment">//相同状态，也可以吧limit和lead也放入dp数组中（多开两个维度）</span></span><br><span class="line">    ll ret=<span class="number">0</span>;<span class="comment">//暂时记录当前方案数</span></span><br><span class="line">    <span class="keyword">int</span> res=limit?a[len-pos+<span class="number">1</span>]:<span class="number">9</span>;<span class="comment">//res当前位能取到的最大值，limit的作用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=res;i++)<span class="comment">//搜索每个可取的数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有前导0并且当前位也是前导0</span></span><br><span class="line">        <span class="keyword">if</span>((!i)&amp;&amp;lead) ret+=<span class="built_in">dfs</span>(……,……,……,i==res&amp;&amp;limit);</span><br><span class="line">        <span class="comment">//有前导0但当前位不是前导0，当前位就是最高位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i&amp;&amp;lead) ret+=<span class="built_in">dfs</span>(……,……,……,i==res&amp;&amp;limit); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(根据题意而定的判断) ret+=<span class="built_in">dfs</span>(……,……,……,i==res&amp;&amp;limit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;!lead) dp[pos][pre][st]……[……]=ret;<span class="comment">//没前导零，后面无限制，当前状态方案数记录</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">part</span><span class="params">(ll x)</span><span class="comment">//把数按位拆分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) a[++len]=x%<span class="number">10</span>,x/=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span> dp);<span class="comment">//初始化-1（因为有可能某些情况下的方案数是0）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(……,……,……,……);<span class="comment">//进入记搜</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(l) <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">part</span>(r)-<span class="built_in">part</span>(l<span class="number">-1</span>));<span class="comment">//[l,r](l!=0)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">part</span>(r)-<span class="built_in">part</span>(l));<span class="comment">//从0开始要特判</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<h3 id="【例题】"><a href="#【例题】" class="headerlink" title="【例题】"></a>【例题】</h3><ul>
<li><h4 id="45届icpc上海Sum-of-Log"><a href="#45届icpc上海Sum-of-Log" class="headerlink" title="45届icpc上海Sum of Log"></a><a href="https://ac.nowcoder.com/acm/contest/21785/C">45届icpc上海Sum of Log</a></h4></li>
</ul>
<p>一般的数位DP套路题都是一个数满足什么性质，而这题是两个数满足一个性质就是与起来是0。那么我们类比一下，原来限制单个数后面取值的limit现在要有两个，而当前搜索的位置因为两个数位置总是同步的，所以只需要一个。因为两个数&amp;起来等于0，那么他们相加是不进位的，又取了log，答案就是最高位的位置加1，所以每一位的贡献就是这位是最高位的数量乘以这位的位置+1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M,K;</span><br><span class="line"><span class="keyword">int</span> num1[<span class="number">33</span>],num2[<span class="number">33</span>],dp[<span class="number">33</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line"><span class="keyword">int</span> bit[<span class="number">33</span>];</span><br><span class="line"><span class="keyword">int</span> L, R, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> limit1, <span class="keyword">int</span> limit2, <span class="keyword">int</span> zero)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(now == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//枚举完了</span></span><br><span class="line">	<span class="keyword">int</span> &amp;x = dp[now][limit1][limit2];</span><br><span class="line">	<span class="keyword">if</span>(~x) <span class="keyword">return</span> x;<span class="comment">//已经搜过了</span></span><br><span class="line">	<span class="keyword">if</span> ((!limit1)&amp;&amp;(!limit2)&amp;&amp;!zero) <span class="keyword">return</span> x = bit[now+<span class="number">1</span>];<span class="comment">//没有限制，后面就是全部的组合</span></span><br><span class="line">	<span class="keyword">int</span> end1 = limit1?num1[now]:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> end2 = limit2?num2[now]:<span class="number">1</span>;</span><br><span class="line">	x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,end1)&#123;</span><br><span class="line">		<span class="built_in">rep</span>(j,<span class="number">0</span>,end2)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&amp;j) <span class="keyword">continue</span>;<span class="comment">//不符合&amp;=0</span></span><br><span class="line">			<span class="keyword">if</span>(zero&amp;&amp;(i|j))&#123;</span><br><span class="line">				temp = <span class="built_in">dfs</span>(now<span class="number">-1</span>,limit1&amp;&amp;(i==end1),limit2&amp;&amp;(j==end2),<span class="number">0</span>);</span><br><span class="line">				x = (x+temp)%mod;<span class="comment">//为上一层累加</span></span><br><span class="line">				cnt = (cnt+temp)%mod;<span class="comment">//当前位是最高位</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				x = (x+<span class="built_in">dfs</span>(now<span class="number">-1</span>,limit1&amp;&amp;(i==end1),limit2&amp;&amp;(j==end2),zero&amp;&amp;(!(i|j))))%mod;<span class="comment">//为上一层累加</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans=(ans+cnt*(now+<span class="number">1</span>))%mod;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">part</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">-1</span>;<span class="comment">//数字放在【0，len】中</span></span><br><span class="line">	<span class="keyword">while</span>(X || Y) &#123;</span><br><span class="line">		num1[++len] = X%<span class="number">2</span>, X/=<span class="number">2</span>;</span><br><span class="line">		num2[len] = Y%<span class="number">2</span>, Y/=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">mem</span>(dp,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">dfs</span>(len,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">wtl</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line">	<span class="built_in">part</span>(L,R);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	bit[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">32</span>) bit[i] = bit[i<span class="number">-1</span>]*<span class="number">3</span>%mod;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><h4 id="2020Hong-Kong-J-Junior-Mathematician"><a href="#2020Hong-Kong-J-Junior-Mathematician" class="headerlink" title="2020Hong Kong   J. Junior Mathematician"></a><a href="https://codeforces.com/gym/102452/problem/J">2020Hong Kong   J. Junior Mathematician</a></h4></li>
</ul>
<p>这题与上题不同，只有一个数，我们可以用前缀和相减来求，但是数字太大有5000位，需要用到字符串来存储，对字符串求减一涉及到借位，可能有些麻烦（其实也并不麻烦）。这里提供另一种思路，就是判断L这个数是否满足即可。</p>
<p><strong>参数分析：</strong></p>
<ol>
<li>满足f（x）= x（mod M） 我们可以构造g（x）= f（x）- x，那么条件变成g（x）= 0 （mod M）</li>
<li>计算f（x）时，为了避免重复计算贡献，规定当前数字只会跟前面的数字产生贡献，那么我们只需要记录每一位数字的前缀和pre，然后当前数字的贡献就是j * pre</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M,K;</span><br><span class="line"><span class="keyword">int</span> bit[<span class="number">5009</span>],A[<span class="number">5009</span>],dp[<span class="number">5009</span>][<span class="number">61</span>][<span class="number">61</span>][<span class="number">2</span>],id,st[<span class="number">5009</span>][<span class="number">61</span>][<span class="number">61</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> R[<span class="number">5009</span>],L[<span class="number">5009</span>];</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> pre,<span class="keyword">int</span> fx, <span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(now==(N+<span class="number">1</span>))&#123;</span><br><span class="line">		f = (fx==<span class="number">0</span>);<span class="comment">//判断X是否可行</span></span><br><span class="line">		<span class="keyword">return</span> f;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (st[now][pre][fx][limit]==id) <span class="keyword">return</span> dp[now][pre][fx][limit];<span class="comment">//这样可以不用初始化dp数组，等于当前id说明是本组数据，不同组的模数是不同的，所以同一个状态的值可能不同</span></span><br><span class="line">	st[now][pre][fx][limit] = id;</span><br><span class="line">	<span class="keyword">int</span> lim = limit?A[now]:<span class="number">9</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,lim)&#123;</span><br><span class="line">		<span class="keyword">int</span> dif = <span class="built_in">mo</span>((fx+i*pre-i*bit[N-now]),M);</span><br><span class="line">		ans = ans+<span class="built_in">dfs</span>(now+<span class="number">1</span>,(pre+i)%M,dif,limit&amp;&amp;(i==A[now]));</span><br><span class="line">	&#125;</span><br><span class="line">	ans = (ans+mod)%mod;</span><br><span class="line">	dp[now][pre][fx][limit] = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">part</span><span class="params">(<span class="keyword">char</span> X[])</span></span>&#123;</span><br><span class="line">	<span class="comment">//printf(&quot;!---%s\n&quot;,X+1);</span></span><br><span class="line">	++id;<span class="comment">//标记测试数据组别</span></span><br><span class="line">	N = <span class="built_in">strlen</span>(X+<span class="number">1</span>);	</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N) A[i] = X[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s %s %d&quot;</span>,L+<span class="number">1</span>,R+<span class="number">1</span>,&amp;M);</span><br><span class="line">	N = <span class="built_in">strlen</span>(R+<span class="number">1</span>);</span><br><span class="line">    bit[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">		bit[i] = bit[i<span class="number">-1</span>]*<span class="number">10</span>%M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="built_in">part</span>(R);</span><br><span class="line">	f = <span class="number">0</span>;</span><br><span class="line">	ans-=<span class="built_in">part</span>(L);</span><br><span class="line">	<span class="comment">//debug(f);</span></span><br><span class="line">	ans+=f;<span class="comment">//f是判断L是否有效，有效的话就为1（前缀和相减时多减了1加回来）</span></span><br><span class="line">	<span class="built_in">wtl</span>(<span class="built_in">mo</span>(ans,mod));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>树形DP</title>
    <url>/2021/10/08/%E6%A0%91%E5%BD%A2DP/</url>
    <content><![CDATA[<h3 id="P1352-没有上司的舞会"><a href="#P1352-没有上司的舞会" class="headerlink" title="P1352 没有上司的舞会"></a><a href="https://www.luogu.com.cn/problem/P1352">P1352 没有上司的舞会</a></h3><p><strong>题意：</strong>求选择的点的权值和最大。限制条件：若父节点被选，子节点不能被选</p>
<p>状态机模型，不过不能用循环枚举顺序，用树上dfs递归的方式进行枚举。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************</span></span><br><span class="line"><span class="comment">| Author:  pigstar</span></span><br><span class="line"><span class="comment">| Problem: P1352 没有上司的舞会</span></span><br><span class="line"><span class="comment">| Contest: Luogu</span></span><br><span class="line"><span class="comment">| URL:     https://www.luogu.com.cn/problem/P1352</span></span><br><span class="line"><span class="comment">| When:    2021-10-08 09:33:54</span></span><br><span class="line"><span class="comment">| </span></span><br><span class="line"><span class="comment">| Memory:  128 MB</span></span><br><span class="line"><span class="comment">| Time:    1000 ms</span></span><br><span class="line"><span class="comment">*******************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	iocin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,x);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn],vis[maxn];</span><br><span class="line">vi G[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u] = <span class="number">1</span>;<span class="comment">//搜索过了</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,(<span class="built_in">sz</span>(G[u])<span class="number">-1</span>))&#123;</span><br><span class="line">		<span class="keyword">int</span> to = G[u][i];</span><br><span class="line">		<span class="keyword">if</span>(vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(to);</span><br><span class="line">		dp[u][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[to][<span class="number">0</span>],dp[to][<span class="number">1</span>]);<span class="comment">//当前节点不去，下属可以去也可以不去</span></span><br><span class="line">		dp[u][<span class="number">1</span>]+=dp[to][<span class="number">0</span>];<span class="comment">//当前节点去，下属不能去</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		cin&gt;&gt; N;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N) cin &gt;&gt; dp[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> L, K;</span><br><span class="line">			cin &gt;&gt; L &gt;&gt; K;</span><br><span class="line">			st[L] = <span class="number">1</span>;<span class="comment">//标记不是根节点</span></span><br><span class="line">			G[K].<span class="built_in">pb</span>(L);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!st[i])&#123;<span class="comment">//从根节点开始dfs</span></span><br><span class="line">				<span class="built_in">dfs</span>(i);</span><br><span class="line">				cout &lt;&lt; <span class="built_in">max</span>(dp[i][<span class="number">1</span>],dp[i][<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2196">Computer</a></h3><p><strong>题意：</strong>求每个点与其他任意一点的最远距离</p>
<p>给的是一棵树，每个节点都有且只有一个父亲。且本题节点1是根节点。</p>
<p>对于一个节点他的最远距离有两种</p>
<ul>
<li><strong>向下：</strong>以当前节点为根的子树的深度（由dfs1可得到）</li>
<li><strong>向上：</strong>父节点的最远距离再加上当前节点到父节点的距离</li>
</ul>
<p>然后这两种取最大值</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************</span></span><br><span class="line"><span class="comment">| Author:  pigstar</span></span><br><span class="line"><span class="comment">| Problem: Computer</span></span><br><span class="line"><span class="comment">| Contest: HDOJ</span></span><br><span class="line"><span class="comment">| URL:     http://acm.hdu.edu.cn/showproblem.php?pid=2196</span></span><br><span class="line"><span class="comment">| When:    2021-10-08 10:04:01</span></span><br><span class="line"><span class="comment">| </span></span><br><span class="line"><span class="comment">| Memory:  32 MB</span></span><br><span class="line"><span class="comment">| Time:    1000 ms</span></span><br><span class="line"><span class="comment">*******************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	iocin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,x);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> id[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,v;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sz</span>(G[u]); i ++ )&#123;</span><br><span class="line">		<span class="keyword">int</span> to = G[u][i].to, v = G[u][i].v;</span><br><span class="line">		<span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs1</span>(to,u);<span class="comment">//先递归到子节点，由儿子信息得到父亲节点信息</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">chkmx</span>(dp[u][<span class="number">0</span>],dp[to][<span class="number">0</span>]+v))&#123;</span><br><span class="line">			id[u]= to;<span class="comment">//记录最长路径的方向</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sz</span>(G[u]); i ++ )&#123;</span><br><span class="line">		<span class="keyword">int</span> to = G[u][i].to, v = G[u][i].v;</span><br><span class="line">		<span class="keyword">if</span>(to==fa||to==id[u]) <span class="keyword">continue</span>;<span class="comment">//去掉最长距离就是次长距离了</span></span><br><span class="line">		<span class="built_in">chkmx</span>(dp[u][<span class="number">1</span>],dp[to][<span class="number">0</span>]+v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sz</span>(G[u]); i ++ )&#123;</span><br><span class="line">		<span class="keyword">int</span> to = G[u][i].to, v = G[u][i].v;</span><br><span class="line">		<span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(to==id[u])&#123;<span class="comment">//当前是最长路径，不能重复走所以只能次长距离</span></span><br><span class="line">			dp[to][<span class="number">2</span>] = <span class="built_in">max</span>(dp[u][<span class="number">2</span>],dp[u][<span class="number">1</span>])+v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			dp[to][<span class="number">2</span>] = <span class="built_in">max</span>(dp[u][<span class="number">2</span>],dp[u][<span class="number">0</span>])+v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs2</span>(to,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N))&#123;</span><br><span class="line">    <span class="comment">//多组测试数据，初始化</span></span><br><span class="line">		<span class="built_in">mem</span>(dp,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N) &#123;</span><br><span class="line">			id[i] = <span class="number">1</span>;</span><br><span class="line">			G[i].<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//建图</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">			<span class="keyword">int</span> a,b;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			G[i].<span class="built_in">pb</span>(&#123;a,b&#125;);</span><br><span class="line">			G[a].<span class="built_in">pb</span>(&#123;i,b&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">		<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">//求出向下的最长距离dp[][0]和次长距离dp[][1]</span></span><br><span class="line">		<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">//求出向上的最长距离</span></span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;</span><br><span class="line">			<span class="built_in">wtl</span>(<span class="built_in">max</span>(dp[i][<span class="number">0</span>],dp[i][<span class="number">2</span>]));<span class="comment">//向下和向上取Max</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Strategic-game"><a href="#Strategic-game" class="headerlink" title="Strategic game"></a><a href="http://poj.org/problem?id=1463">Strategic game</a></h3><p><strong>题意：</strong>给你一幅图，要求每条边至少一个端点为1，求所有端点权值和最小值。</p>
<p>也是状态机加上dfs的递归顺序。</p>
<ul>
<li>如果当前节点为1，相邻节点可以为0，1，累加其中的最小值。（别忘了加上当前节点本身的1）</li>
<li>如果当前节点为0，相邻节点必须为1，累加即可。</li>
</ul>
<p>从根节点开始先递归在DP计算，这样最后答案在根节点的dp数组中。</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************</span></span><br><span class="line"><span class="comment">| Author:  pigstar</span></span><br><span class="line"><span class="comment">| Problem: Strategic game</span></span><br><span class="line"><span class="comment">| Contest: POJ - Southeastern Europe 2000</span></span><br><span class="line"><span class="comment">| URL:     http://poj.org/problem?id=1463</span></span><br><span class="line"><span class="comment">| When:    2021-10-08 14:39:50</span></span><br><span class="line"><span class="comment">| </span></span><br><span class="line"><span class="comment">| Memory:  10 MB</span></span><br><span class="line"><span class="comment">| Time:    2000 ms</span></span><br><span class="line"><span class="comment">*******************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	iocin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,x);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">2</span>],B[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line">vi G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dp[u][<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//当前节点本身的权值</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="built_in">sz</span>(G[u])<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> to = G[u][i];</span><br><span class="line">		<span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(to,u);<span class="comment">//先递归再计算</span></span><br><span class="line">		dp[u][<span class="number">1</span>] += <span class="built_in">min</span>(dp[to][<span class="number">1</span>],dp[to][<span class="number">0</span>]);<span class="comment">//当前为1</span></span><br><span class="line">		dp[u][<span class="number">0</span>]+=dp[to][<span class="number">1</span>];<span class="comment">//当前为0</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N))&#123;</span><br><span class="line">    <span class="built_in">mem</span>(dp,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,N) G[i].<span class="built_in">clear</span>();<span class="comment">//初始化，否则MLE</span></span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">1</span>,N)&#123;<span class="comment">//建图</span></span><br><span class="line">			<span class="keyword">int</span> a,k,b;</span><br><span class="line">			cin &gt;&gt; a;</span><br><span class="line">			<span class="built_in">getchar</span>();</span><br><span class="line">			<span class="built_in">getchar</span>();</span><br><span class="line">			cin &gt;&gt; k;</span><br><span class="line">			<span class="built_in">getchar</span>();</span><br><span class="line">			<span class="built_in">rep</span>(j,<span class="number">1</span>,k)&#123;</span><br><span class="line">				cin &gt;&gt; b;</span><br><span class="line">				G[a].<span class="built_in">pb</span>(b);</span><br><span class="line">				G[b].<span class="built_in">pb</span>(a);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">wtl</span>(<span class="built_in">min</span>(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h3 id="FAR-FarmCraft"><a href="#FAR-FarmCraft" class="headerlink" title="FAR-FarmCraft"></a><a href="https://www.luogu.com.cn/problem/P3574">FAR-FarmCraft</a></h3><p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************</span></span><br><span class="line"><span class="comment">| Author:  pigstar</span></span><br><span class="line"><span class="comment">| Problem: P3574 [POI2014]FAR-FarmCraft</span></span><br><span class="line"><span class="comment">| Contest: Luogu</span></span><br><span class="line"><span class="comment">| URL:     https://www.luogu.com.cn/problem/P3574</span></span><br><span class="line"><span class="comment">| When:    2021-10-08 17:52:39</span></span><br><span class="line"><span class="comment">| </span></span><br><span class="line"><span class="comment">| Memory:  125 MB</span></span><br><span class="line"><span class="comment">| Time:    1000 ms</span></span><br><span class="line"><span class="comment">*******************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF_L 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cout&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readI(l,r,A) for(int pig=l;pig<span class="meta-string">&lt;=r;pig++)	iocin &gt;</span>&gt; A[pig]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(ll x)</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,x);&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmx</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">chkmn</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,N,M;</span><br><span class="line"><span class="keyword">int</span> A[maxn],siz[maxn];<span class="comment">//遍历完子树的时间，每条边是1</span></span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line">vi G[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];<span class="comment">//以i为根的子树所有居民安装完电脑的时间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sa = siz[a], sb = siz[b];</span><br><span class="line">	a = dp[a], b = dp[b];</span><br><span class="line">	<span class="keyword">return</span> sa-a&lt;sb-b;<span class="comment">//需要等待的时间从小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u!=<span class="number">1</span>) dp[u] = A[u];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="built_in">sz</span>(G[u])<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> to = G[u][i];</span><br><span class="line">		<span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(to,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(G[u]),cmp);<span class="comment">//贪心排序</span></span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="built_in">sz</span>(G[u])<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> to = G[u][i];</span><br><span class="line">		<span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">chkmx</span>(dp[u],dp[to]+siz[u]+<span class="number">1</span>);<span class="comment">//当前子树完成时间是所有儿子子树完成时间的最大值，+1是当前节点去儿子的时间，回来覆盖在了等待时间内</span></span><br><span class="line">		siz[u] += siz[to]+<span class="number">2</span>;<span class="comment">//每次回到父亲节点增加的时间都是儿子遍历完时间加2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,N) cin &gt;&gt; A[i];</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">2</span>,N)&#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		G[a].<span class="built_in">pb</span>(b);</span><br><span class="line">		G[b].<span class="built_in">pb</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">wtl</span>(<span class="built_in">max</span>(dp[<span class="number">1</span>],siz[<span class="number">1</span>]+A[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<p><strong>未完待续…</strong></p>
]]></content>
  </entry>
  <entry>
    <title>第九届“图灵杯”NEUQ-ACM程序设计竞赛个人赛  K金牌厨师</title>
    <url>/2022/01/18/%E7%AC%AC%E4%B9%9D%E5%B1%8A%E2%80%9C%E5%9B%BE%E7%81%B5%E6%9D%AF%E2%80%9DNEUQ-ACM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B8%AA%E4%BA%BA%E8%B5%9B%20%20K%E9%87%91%E7%89%8C%E5%8E%A8%E5%B8%88/</url>
    <content><![CDATA[<p><strong>题目描述</strong><br>Phenix作为食堂的金牌厨师，每天的工作是为同学们准备饭菜，Phenix做出的每一种菜都有一个辣度值，范围是[1,n][1,n]。作为厨师，Phenix提前了解了m位同学的辣度接受范围，第i位同学的辣度接受范围被描述为$$$[l_i,r_i]$$$，表示该同学可以接受辣度值位于这个区间的菜。由于众口难调，每天Phenix会选出部分同学，做出能让这部分同学都接受的辣度的菜。Phenix作为金牌厨师对每天工作的满意程度定义为选出的同学的人数kk和能让这部分同学都接受的菜的种类数xx（这里理解为一种辣度对应一种菜）两者中的最小值，即min(k,x)。(1&lt;=n,m&lt;=300000)。</p>
<p>现在你需要想办法让Phenix的满意程度最大。</p>
<p><strong>输入描述:</strong><br>第一行两个整数n,m，表示菜的辣度最大值和同学的人数(1&lt;=n,m&lt;=300000)。</p>
<p>接下来m行,每行两个整数$$$[l_i,r_i]$$$依次表示第i个同学的辣度接受范围(1&lt;=$$$[l_i,r_i]$$$&lt;=n)</p>
<p><strong>输出描述:</strong><br>一行，表示满意度的最大值。</p>
<p><strong>思路：</strong><br>二分min(k,x)<br>check：如果所有同学中有大于等于mid人共同覆盖的区间大于等于mid则return 1；否则return 0。</p>
<p><strong>代码</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PII pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lcm(a,b) a/gcd(a,b)*b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(a) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Adebug(a,i) cerr&lt;&lt;#a&lt;&lt;<span class="meta-string">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="meta-string">&quot;]=&quot;</span>&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for(int i = (a); i &gt;= (b); i --)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vpii vector<span class="meta-string">&lt;PII&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rvs(s) reverse(s.begin(),s.end())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(s) s.begin(),s.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(s) (int)(s.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(s) ((s) &amp; (-s))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mk(s, t) make_pair(s, t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CN puts(<span class="meta-string">&quot;NO&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CY puts(<span class="meta-string">&quot;YES&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wt</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtl</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wtb</span><span class="params">(string x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmax</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">ckmin</span><span class="params">(T &amp;x, T y)</span></span>&#123;<span class="keyword">return</span> x &gt; y ? x = y, <span class="literal">true</span> : <span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span> (k)&#123;<span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (ll)res * a % p;a = (ll)a * a % p;k &gt;&gt;= <span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> res = <span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res *= a;b&gt;&gt;=<span class="number">1</span>;a*=a;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>&#123;<span class="keyword">return</span> x = ((x%p)+p)%p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> fact[maxn], infact[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jie_init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">1</span>,n) fact[i] = fact[i<span class="number">-1</span>] * i % mod;	</span><br><span class="line">	infact[n] = <span class="built_in">qmi</span>(fact[n],mod<span class="number">-2</span>,mod);</span><br><span class="line">	<span class="built_in">per</span>(i,n<span class="number">-1</span>,<span class="number">0</span>) infact[i] = infact[i+<span class="number">1</span>] * (i+<span class="number">1</span>) % mod;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;<span class="keyword">return</span> fact[n] * infact[m] % mod * infact[n-m] % mod;&#125;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>,N,M,K;</span><br><span class="line"><span class="keyword">int</span> A[maxn],B[maxn],dp[maxn],f[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	vector&lt;PII&gt; stu;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="built_in">min</span>(N,M);</span><br><span class="line">	<span class="keyword">while</span> (M--) &#123;</span><br><span class="line">		<span class="keyword">int</span> l, r;</span><br><span class="line">		 cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		 stu.<span class="built_in">pb</span>(<span class="built_in">mk</span>(l,r));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; check = [&amp;](<span class="keyword">int</span> x)&#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(N+<span class="number">7</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stu.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">			<span class="keyword">int</span> len = stu[i].second - stu[i].first + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (len &gt;= x) &#123;</span><br><span class="line">				k ++;</span><br><span class="line">				st[stu[i].fi+x<span class="number">-1</span>] ++;</span><br><span class="line">				st[stu[i].se+<span class="number">1</span>] --;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				用差分对区间加1</span></span><br><span class="line"><span class="comment">				加了一说明这个位置往前x个都被当前同学覆盖了</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">			st[i] += st[i<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span> (st[i] &gt;= x) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//说明当前位置往前x个被大于等于x个同学覆盖</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>(mid)) ans = mid,l = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IOS</span><br><span class="line">	<span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">	<span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>); <span class="comment">//&lt;3</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>高斯消元</title>
    <url>/2021/11/15/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</url>
    <content><![CDATA[<h1 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h1><blockquote>
<p>默认大家都学过线代了</p>
</blockquote>
<h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a><strong>算法思想</strong>：</h3><ol>
<li><p>就是求解矩阵的过程。把矩阵转化成一个上三角或者下三角的形式，那么只需要把对角线上的元素相乘就可以 $O(n)$ 得到矩阵的值。</p>
</li>
<li><p>如何把矩阵转化成上三角或下三角呢，线性代数告诉我们把第i行的每个元素加上第j行对应的每个元素的k倍，原矩阵大小不变。（同理可以消除列）</p>
</li>
<li><p>判断解的情况：</p>
<p>a) 如果出现某一行，系数矩阵全为0，增广矩阵不全为0，则无解（即出现[0 0 0 0 0 b]，其中b不等于0的情况）（转化为方程就是说 $0 \times x_1 + …+0 \times x_n = b(b \neq 0)$ ,显然这不可能）；</p>
<p>b) 如果是严格上三角，则表明有唯一解；</p>
<p>​    形如下图，以对角线为线，左下角全为0或右上角</p>
<p>​    <img src="https://tse1-mm.cn.bing.net/th/id/R-C.d85ea5d58289c8b027ec7dd7dbb8ec26?rik=CmoIe2fedyOvCQ&amp;riu=http%3a%2f%2fc.biancheng.net%2fuploads%2fallimg%2f190426%2f1KJR1D-5.gif&amp;ehk=VYbXtHCtR86m65HblKk1JWB5G5OO%2bnEn8uOO1nsW7AM%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0&amp;sres=1&amp;sresct=1" alt="上三角下三角矩阵"></p>
</li>
</ol>
<p>   ​    c) 如果增广矩阵有k (k &gt; 0)行全为0（全为0指b也等于0），那么表明有k个变量可以任    意取值，这几个变量即自由变量；对于这种情况，一般解的范围是给定的，令解的取值    有T个，自由变量有V个，那么解的个数就是 TV。</p>
<h3 id="ACWING的基础模板题（防止没买基础课的看不了，题目也加上了）"><a href="#ACWING的基础模板题（防止没买基础课的看不了，题目也加上了）" class="headerlink" title="ACWING的基础模板题（防止没买基础课的看不了，题目也加上了）"></a><strong>ACWING的基础模板题（防止没买基础课的看不了，题目也加上了）</strong></h3><ul>
<li><p><a href="https://www.acwing.com/problem/content/885/">883. 高斯消元解线性方程组 - AcWing题库</a></p>
<ul>
<li><p>题目：</p>
<p><img src="https://s6.jpg.cm/2021/11/15/Iit3LE.png" alt="Iit3LE.png"></p>
</li>
<li><p>代码+板子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = c; i &lt; n + <span class="number">1</span>; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line"></span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">            a[i][n] -= a[j][n] * a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j ++ )</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, a[i][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><a href="https://www.acwing.com/problem/content/886/">884. 高斯消元解异或线性方程组 - AcWing题库</a></p>
<ul>
<li><p>题目：<img src="https://s6.jpg.cm/2021/11/15/IitCbQ.png" alt="IitCbQ.png"></p>
</li>
<li><p>板子+代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">int</span> a[N][N];</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> c, r;</span><br><span class="line">      <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">int</span> t = r;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">              <span class="keyword">if</span> (a[i][c])</span><br><span class="line">                  t = i;</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (!a[t][c]) <span class="keyword">continue</span>;</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[r][i], a[t][i]);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">              <span class="keyword">if</span> (a[i][c])</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                      a[i][j] ^= a[r][j];</span><br><span class="line">  </span><br><span class="line">          r ++ ;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">              <span class="keyword">if</span> (a[i][n])</span><br><span class="line">                  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">              a[i][n] ^= a[i][j] * a[j][n];</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      cin &gt;&gt; n;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j ++ )</span><br><span class="line">              cin &gt;&gt; a[i][j];</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">int</span> t = <span class="built_in">gauss</span>();</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> (t == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; a[i][n] &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Multiple sets of solutions&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="题型分类"><a href="#题型分类" class="headerlink" title="题型分类"></a>题型分类</h3><ul>
<li><p>浮点数消元</p>
<p>系数矩阵为整数或浮点数，消元的时候乘上的系数为浮点数，一般用于求解浮点数解</p>
</li>
<li><p>整数消元</p>
<p>系数矩阵全为整数，消元的时候乘上的系数均为整数，整个消元过程不出现浮点数。由于乘法很容易溢出，一般很少用。（真迫不得已就上Java，Python）</p>
</li>
<li><p>模线性方程组（很有用）</p>
<p>系数矩阵全为整数，消元的时候乘上的系数均为整数，每次运算都模上一个数P，整个消元过程不出现除法。（<strong>因为高斯消元的过程和最后的计算都是只有+-×，对取模后的结果都没影响，这样算出来的结果和原来答案取模后是一样的</strong>）</p>
<ul>
<li>有的是给定解的范围求解的数量，例如：PKU 1830、HDU 3364</li>
<li>有的是求一个解，例如PKU 2065、HDU 3571</li>
<li>有的是求解的存在性，例如PKU1288、PKU 3185。</li>
<li>有的是已知解得绝对值求正负，例如2021icpc济南J</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
</search>
